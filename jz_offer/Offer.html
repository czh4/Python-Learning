<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>剑指Offer</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="7c292b1a-552c-4073-b302-e1073c53efe8" class="page sans"><header><h1 class="page-title">剑指Offer</h1></header><div class="page-body"><nav id="d77081a4-26a8-4e20-931c-45cb5981523e" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#df7c730b-1666-4415-aace-6ead81d14895">【数组】1. 二维数组中的查找</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#b5aabe70-1e2a-4a9d-9c58-f72557987ef1">【字符串】2. 替换空格 — string本身可以历遍</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#c770af67-7ac0-41ab-b565-27ab9369d97f">【链表】3. 从尾到头打印链表 — list的翻转</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#ff9e2422-aacd-4a63-a481-d81e2e3bb692">【数】4. 重建二叉树</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#ba042a9a-5f70-4123-b6d5-208a0a689f10">【栈和队列】5. 用两个栈【先进后出】实现队列【先进先出】</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#89ab0f8d-c812-46ad-8199-fd4a20a7cc1c">【查找和排序】6. 旋转数组的最小数字</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#803a364c-1d33-4784-bdef-f37b8fce42c1">【递归和循环】7. 斐波那契数列</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#667f31ee-3e71-4fd6-929d-5e3e3f507a8c">【递归和循环】8. 跳台阶</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#017707ee-9242-43bc-8174-62ed2135205b">【递归和循环】9. 变态跳台阶</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d35be7db-53e9-4884-ab18-0eba8a539894">【递归和循环】10. 矩形覆盖</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8cbf934c-6f32-4e3c-a02b-33ff82376e41">【位运算】11. 二进制中1的个数</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#df220ed0-3109-4fe7-83cc-01671d0178d0">【代码的完整性】12. 数值的整数次方</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#b06c48b8-4eeb-462f-9e71-9d9edf751e54">【代码的完整性】13. 调整数组顺序使奇数位于偶数前面</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#2ef0efbb-3939-4240-b7dd-9946b123c773">【代码的鲁棒性】14. 链表中倒数第k个结点</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8bdb9cda-943d-4e18-9624-c4e30663b18a">【代码的鲁棒性】15. 反转链表</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e72a749b-e1b9-44b9-8651-6d98e40c7483">【代码的鲁棒性】16. 合并两个排序的链表 — 重复比较的话应该往递归想</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#067e9209-4243-49a3-9b9e-367c2ab5797d">*【代码的鲁棒性】17. 树的子结构</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5fa19299-8135-459b-9b95-18b15c5d5357">【面试思路】18. 二叉树的镜像</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e0e3f231-fc67-4345-8b16-20546d4af4ef">【画图让抽象形象化】19. 顺时针打印矩阵</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#54f02586-2f6b-4751-bc62-70180b4afd4f">【举例让抽象具体化】20. 包含min函数的栈</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#880f00fd-37ec-4517-91db-358b7dcfaf6e">*【举例让抽象具体化】21. 栈的压入、弹出序列</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#aff456bb-c9e0-471b-b6ce-f3e6327f10e0">【队列实现BFS】22. 从上往下打印二叉树</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#47c9982b-e8d3-4248-bb88-9f0c83eeafbb">*【举例让抽象具体化】23. 二叉搜索树的后序遍历序列</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#acef3064-13b4-499b-9b76-9e8fe79daac7">*【举例让抽象具体化】24. 二叉树中和为某一值的路径</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#a65230cf-8d5a-4464-839a-dce25a5ae0d9">【分解让复杂问题简单】25. 复杂链表的复制</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f804fc6e-0963-47d8-ba18-04a193892011">【分解让复杂问题简单】27. 字符串的排列</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#fb7c9bf7-d032-400d-9e27-f893c4a5bab2">【时间效率】28. 数组中出现次数超过一半的数字</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#192f3eb8-45a1-4b5d-86bd-cace8abae9a2">【时间效率】29. 最小的K个数</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#79ed05da-e62a-43df-b5bf-5132099a741f">【时间效率】30. 连续子数组的最大和</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#29cb8fed-6970-4062-b83d-6e0d9a64ea5a">【时间效率】31. 整数中1出现的次数（从1到n整数中1出现的次数）</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#ffaee261-2b2f-4130-b588-6990e6fa98ed">【时间效率】32. 把数组排成最小的数</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d11ea4c0-9f80-4d4b-9019-5d801922107f">【时间空间效率的平衡】33. 丑数</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e2cb0014-db35-4071-a11a-030c39873122">【时间空间效率的平衡】34. 第一个只出现一次的字符位置</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#95ad73d2-a1df-4da3-8a16-daf07b16d561">35. 数组中的逆序对</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5b151752-ad25-465b-b76f-21fa09678781">36. 两个链表的第一个公共结点</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4c186a3f-ddef-4c34-bd47-db2fe81e572b">37. 数字在排序数组中出现的次数</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#1f7c65f3-0818-4623-a85f-070fc42548be">38. 二叉树的深度</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#0e2c2988-4683-4ede-ac4f-5c1458f1b99b">39. 平衡二叉树</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#be8baaa2-286b-4c0a-a30f-f7ac1363415c">40. 数组中只出现一次的数字</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e9128db1-0e54-4bdd-82fd-d38eb30363d6">41. 和为S的连续正数序列</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8ea15a24-207e-48ac-9467-9301dca27dce">42. 和为S的两个数字</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5549db68-291e-4307-8c6f-91097cc67dd6">43. 左旋转字符串</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#cf83731c-44d7-42d8-82df-9f877d6dbb9a">44. 翻转单词顺序列</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#0a03cc70-f092-468e-9934-7606a1703bd2">45. 扑克牌顺子</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7a1c1f49-55e9-4dbe-979b-fcc813df1553">46. 圆圈中最后剩下的数</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#927b2b29-f78e-4200-ac3f-c8262c093261">【发散思维能力】47. 求1+2+3+...+n</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#2d48b5c1-da6d-4ff5-bb11-96793302c5aa">48. 不用加减乘除做加法</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f1bd3f97-bde2-4965-9074-1688bf8cae7c">49. 把字符串转换成整数</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#eda69870-12be-477b-9842-517c2368a068">50. 数组中重复的数字</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#006161f5-b49c-4ac7-9197-2cf152309346">51. 构建乘积数组</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#1e5a9a81-e44d-42d2-a3f6-96004fcf3981">52. 正则表达式匹配</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6cada625-974a-44c9-82f3-5d030e4217c0">53. 表示数值的字符串</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f789e4d8-71c5-4f8d-b2de-59ef524259ea">54. 字符流中第一个不重复的字符</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#79ea4ef2-c486-4d7d-832b-3dc0aa83f08d">55. 链表中环的入口结点</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#dc035ed1-5e2f-4054-ba6e-4165c7aeb877">56. 删除链表中重复的结点</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#a67b67bc-1592-4a63-a28d-2c8da10375b4">57. 二叉树的下一个结点</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#782384fe-fb41-4b28-8765-43064fbe5bcd">58. 对称的二叉树</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8bc82c66-35ff-4d5f-a4e7-60453132a1eb">59. 按之字形顺序打印二叉树</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e4012643-a452-413c-8f8c-3051cc8ee2a5">60. 把二叉树打印成多行</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7c997f21-50a7-40eb-9e32-65ac8db4a087">61. 序列化二叉树</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9f3dc15b-dd7d-4bc5-bf3c-2ac51a52a44d">62. 二叉搜索树的第k个结点</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f251afeb-b028-4752-ae01-ed90a174f0b0">63. 数据流中的中位数</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#df640cd1-1411-4ea1-993d-7387240cd4d6">64. 滑动窗口的最大值</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#16456b90-0a98-439e-a5ef-30794f89447f">65. 矩阵中的路径</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#61856d84-06de-4ced-bf09-58a52f84cfdb">66. 机器人的运动范围</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#7ccf7627-1b44-427b-a81f-dc58e3bbc1a4">67. 剪绳子</a></div></nav><hr id="ba083779-a08e-4818-8ade-4753720920af"/><h3 id="df7c730b-1666-4415-aace-6ead81d14895" class="">【数组】1. 二维数组中的查找</h3><p id="6e3ad1d5-2ede-43a7-8cf1-3010cecf523c" class="">在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><p id="41caadb4-5a7c-4558-9fb2-db53fb478d5e" class=""><strong>题解</strong></p><figure class="block-color-orange callout" style="white-space:pre-wrap;display:flex" id="25af2fa8-5a24-43d0-92c1-cd46e2094a13"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>记得考虑空数组！</strong></div></figure><ul id="17ec4510-c62b-4787-9f76-32d85a89dea2" class="bulleted-list"><li>左下/右上元素移动法：复杂度为O(N)</li></ul><pre id="90656280-1d55-4c4b-89fb-f37226ae4c47" class="code"><code># 左下/右上元素移动法
class Solution:
    # array 二维列表
    def Find(self, target, array):
        # <strong>考虑空数组</strong>
        if len(array) == 0 or len(array[0]) == 0:
            return False
				# 右上走策略，从左下角开始
        row = len(array)-1
        col = 0
        while target != array[row][col]:
            if target &lt; array[row][col]:
                if row == 0:
                    return False
                row -= 1
            else:
                if col == len(array[0])-1:
                    return False
                col +=1
        return True</code></pre><ul id="fd5d3484-1dd0-4f3a-b4d6-0750b66db07b" class="bulleted-list"><li>N行二分查找：复杂度为O(N*logN)</li></ul><pre id="e5c7aaf8-641f-4875-a23f-6e6fe27da679" class="code"><code># <strong>N行二分查找</strong>
class Solution:
    # array 二维列表
    def Find(self, target, array):
        # <strong>考虑空数组</strong>
        if len(array) == 0 or len(array[0]) == 0:
            return False
        row = len(array)-1
        col = 0
        for row in range(len(array)):
            if array[row][0] &lt;= target &lt;= array[row][len(array[0])-1]:
                l = 0
                r = len(array[0])-1
                while l&lt;=r:
                    <mark class="highlight-red_background">mid = l + (r-l)//2 #必须是// 因为要整除</mark>
                    if target == array[row][mid]:
                        return True
                    elif target &lt; array[row][mid]:
                        <mark class="highlight-red_background">r = mid-1</mark>
                    else:
                        <mark class="highlight-red_background">l = mid+1 </mark>
        return False</code></pre><h3 id="b5aabe70-1e2a-4a9d-9c58-f72557987ef1" class="">【字符串】2. 替换空格 — string本身可以历遍</h3><p id="bf7a9eb7-4946-44bb-8c3c-abeaadfe7a8e" class="">请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><p id="e40318e7-8d1d-40f1-a30d-86683ad3ee70" class=""><strong>题解</strong></p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="9988d327-7e4e-4253-a88e-813f91febfb6"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><mark class="highlight-orange"><strong>string本身可以历遍</strong></mark></div></figure><pre id="679ffb7a-b166-4812-884c-e39dbc99ac6c" class="code"><code>class Solution:
    # s 源字符串
    def replaceSpace(self, s):
        # write code here
        a=&#x27;&#x27;
        for l in s:
            if l == &#x27; &#x27;:
                a += &#x27;%20&#x27;
            else:
                a += l
        return a</code></pre><h3 id="c770af67-7ac0-41ab-b565-27ab9369d97f" class="">【链表】3. 从尾到头打印链表 — list的翻转</h3><p id="cade93e6-c23f-4fc8-97df-526185eef91b" class="">输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="44c52475-0d80-499e-bbd3-b954e015c57b"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><mark class="highlight-orange"><strong>1. 注意空值啊！！ </strong></mark></div></figure><figure class="block-color-orange callout" style="white-space:pre-wrap;display:flex" id="69dbc0e9-7ded-4603-9bbf-2425da1b84d1"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"><strong>2. list翻转就是list[n::-1] — 从第n个位置坐标开始 截取顺序相反，n为空则是整个反转                   x[startAt : endBefore : skip]</strong></div></figure><p id="54a7b553-a6ec-4ecc-8631-da5e609525ac" class=""><strong>题解</strong></p><pre id="227e645e-dd06-4a85-8d06-57c00f035273" class="code"><code># 遍历，新创一个数组保存
class Solution:
    # 返回从尾部到头部的列表值序列，例如[1,2,3]
    def printListFromTailToHead(self, listNode):
        # <strong>注意空值</strong>
        if listNode is None:
            return []
        res=[]
        while listNode is not None:
            res.append<mark class="highlight-yellow_background">(</mark><mark class="highlight-red_background"><strong>listNode.val</strong></mark>)
            listNode=<mark class="highlight-red_background"><strong>listNode.next</strong></mark>
        return <mark class="highlight-red_background"><strong>res[::-1]</strong></mark>
<strong><mark class="highlight-red_background"># 递归</mark></strong>
def printListFromTailToHead(self, listNode): 
    # write code here 
    if listNode is None: 
        return []
    return self.printListFromTailToHead(listNode.next) + [listNode.val]

func(next1) + [next0.val]
func(next2) + [next1.val] + [next0.val]
nextn == None  --&gt;  [] + [nextn-1.val] + ... + [next0.val]

# 利用栈先入后出的特性完成 (待补充)</code></pre><h3 id="ff9e2422-aacd-4a63-a481-d81e2e3bb692" class="">【数】4. 重建二叉树</h3><p id="6ad68635-a4be-445e-8ab7-41fffcfd50d1" class="">输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p id="bd471217-fd92-4049-9cc0-7a07751af43b" class=""><strong>题解</strong></p><p id="911282b0-ec94-41e0-85cb-286e34abc7b8" class="">根据中序遍历和前序遍历可以确定二叉树，具体过程为：</p><ol id="1c04d63a-c3ba-4fab-baa4-96aa61981232" class="numbered-list" start="1"><li>根据前序序列第一个结点确定根结点</li></ol><ol id="cd505b46-8012-45dd-9506-042269382df1" class="numbered-list" start="2"><li>根据根结点在中序序列中的位置分割出左右两个子序列</li></ol><ol id="4dbe7af8-357f-4480-b58f-5016a31dce89" class="numbered-list" start="3"><li>对左子树和右子树分别递归使用同样的方法继续分解</li></ol><p id="421c6988-b1e1-4757-bee0-fa1a21fb7ab1" class="">例如：前序序列{1,2,4,7,3,5,6,8} = pre中序序列{4,7,2,1,5,3,8,6} = in</p><ol id="1f4941b6-897f-459e-95bd-49e0bef79e9b" class="numbered-list" start="1"><li>根据当前前序序列的第一个结点确定根结点，为 1</li></ol><ol id="c91cf6ad-74dc-473c-bd63-8157242e623e" class="numbered-list" start="2"><li>找到 1 在中序遍历序列中的位置，index为3，为 in[3]</li></ol><ol id="415d90eb-dc6c-488a-8187-0b6b0df33aaf" class="numbered-list" start="3"><li>切割左右子树，则 in[3] 前面的为左子树， in[3] 后面的为右子树</li></ol><ol id="82ea3284-8d92-4ec3-acb1-8c7f485ebc5f" class="numbered-list" start="4"><li>则切割后的<strong>左子树前序序列</strong>为：{2,4,7}，切割后的<strong>左子树中序序列</strong>为：{4,7,2}；<ul id="36de8a1a-b7cd-4630-9dd5-2b7c585c9900" class="bulleted-list"><li>切割后的<strong>右子树前序序列</strong>为：{3,5,6,8}，切割后的<strong>右子树中序序列</strong>为：{5,3,8,6}</li></ul></li></ol><ol id="f37eb99a-1472-43a8-ba10-51174d8a5387" class="numbered-list" start="5"><li>对子树分别使用同样的方法分解</li></ol><pre id="620c0bbe-8e3b-47bc-a6e6-c55f529c5903" class="code"><code>class Solution:
    def reConstructBinaryTree(self, pre, tin):
        if not pre or not tin:
            return None
				# 前序序列第一个为root 
        <mark class="highlight-red_background">root = </mark><mark class="highlight-red_background"><strong>TreeNode(pre.pop(0)</strong></mark><mark class="highlight-red_background">)</mark> #要不断pop根部达到trimming的效果
				# 找中序序列中root位置
        index = tin.index(<mark class="highlight-red_background"><strong>root.val</strong></mark>)
				# 先<mark class="highlight-red_background"><strong>递归</strong></mark>找左子树
        root<strong>.left </strong>= self.reConstructBinaryTree(pre, <mark class="highlight-red_background">tin[:index]</mark>)
				# 再<mark class="highlight-red_background"><strong>递归</strong></mark>找右子树
        root<strong>.right </strong>= self.reConstructBinaryTree(pre, <mark class="highlight-red_background">tin[index + 1:]</mark>)
        return root</code></pre><pre id="e63c1e86-5a96-4e37-9f2c-410b20e48753" class="code"><code>定根：root = <strong>TreeNode(</strong>pre.pop(0))
取值：<strong>root.val</strong></code></pre><h3 id="ba042a9a-5f70-4123-b6d5-208a0a689f10" class="">【栈和队列】5. 用两个栈【先进后出】实现队列【先进先出】</h3><p id="14441a91-c263-4e1a-8ee8-32629f506d93" class="">用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><p id="b5cad0b9-c5ce-4ae2-990f-346b5b316e88" class=""><strong>题解</strong></p><p id="f7e531a2-5f0e-43cc-a480-89bf6a71a24f" class="">创两个栈，一个压入，一个弹出</p><p id="0c3af4af-b51c-4e64-a8e1-bc35cf86a8c1" class="">压入时正常操作</p><p id="800ee0b6-5ad3-4846-96af-0d5dfc549598" class="">弹出时先把stackpush的数据再压入stackpop中，顺序就能反过来。不过要先判断stackpop中是否有元素，不为空时直接弹出stackpop中数据</p><pre id="d250bfc3-84e3-4ee7-a2c0-b731d17de7a3" class="code"><code>class Solution:
<strong>    def __init__(self):
        self.stackpush=[]
        self.stackpop=[]</strong>
    def push(self, node):
        <strong>self.</strong>stackpush.append(node)
    def pop(self):
        if len(self.stackpop) == 0:
						<mark class="highlight-red_background"><strong># FIFO 先进先出</strong></mark>
            while len(self.stackpush) &gt; 0:
                <strong>self.</strong>stackpop.append(<strong>self.stackpush.</strong><mark class="highlight-red_background"><strong>pop(</strong></mark><strong>)</strong>) #FIFO stackpush的第一个应该被pop out
            return <strong>self.</strong>stackpop<mark class="highlight-red_background">.pop()</mark>
        else:
            return <strong>self.</strong>stackpop.pop()</code></pre><h3 id="89ab0f8d-c812-46ad-8199-fd4a20a7cc1c" class="block-color-yellow_background">【查找和排序】6. 旋转数组的最小数字</h3><p id="dd0965e7-5007-4902-a5e8-d502c581a80a" class="">把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p><p id="1d4acee0-f6d8-4e6d-82f7-553b444a9ffa" class="">输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p><p id="fd5109c0-61b0-4cd5-9503-dbb04de2760b" class="">例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p><p id="e10b2022-114c-4280-ad4e-e8f94ca2f4cf" class="">NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><p id="bb91e64c-64dd-4378-89cb-5cb8989f953f" class=""><strong>题解</strong></p><div id="f0caf5d0-df21-4a74-8aa7-a74eca2a6ef0" class="column-list"><div id="065b14ef-7711-4067-9d07-f465d66fea6a" style="width:50%" class="column"><figure id="a132de74-2f2c-43c9-80ca-95e36841f056" class="image"><a href="Offer/Untitled.png"><img style="width:647px" src="Offer/Untitled.png"/></a><figcaption>二分法思想，从中间开始判断左边/右边哪个是单调递增数列</figcaption></figure></div><div id="95cf7800-5f47-4e6b-852c-5f5693a7cb14" style="width:50%" class="column"><figure id="5d337956-3782-43c9-b1eb-a00af696930e" class="image"><a href="Offer/Untitled%201.png"><img style="width:826px" src="Offer/Untitled%201.png"/></a><figcaption>特殊情况</figcaption></figure></div></div><pre id="19f04157-0c06-427e-be00-3f8ee8ae2b2d" class="code"><code># 二分查找
class Solution:
    def minNumberInRotateArray(self, rotateArray):
        # write code here
        if len(rotateArray) == 0:
            return 0
        if len(rotateArray) == 1:
            return rotateArray[0]
        <mark class="highlight-red_background">l = 0 #array的头部
</mark>        <mark class="highlight-red_background">r = len(rotateArray)-1 #array尾巴</mark>
        while r &gt;= l:
            <mark class="highlight-red_background"><strong>mid = l+(r-l)//2</strong></mark>
            if rotateArray[mid] &lt; rotateArray[mid-1]: #mid正好小于前一个值，正好是节点
                return rotateArray[mid]
            if rotateArray[mid] &lt; rotateArray[0]: #mid小于头头，证明已经过了节点，r应该变为mid-1
                <mark class="highlight-red_background">r = mid-1</mark>
            else: #mid大于头头，证明还在单调递增当中，l应该改为mid+1
                <mark class="highlight-red_background">l = mid+1</mark>
# 单边查找
class Solution:
    def minNumberInRotateArray(self, rotateArray):
        # write code here
        <strong><mark class="highlight-red_background">pre = -7e20 # 先设置一个很小的数</mark></strong>
        for num in rotateArray:
            if num &lt; pre :
                return num
            pre = num 
        if len(rotateArray) == 0:
            return 0
        return rotateArray[0]</code></pre><h3 id="803a364c-1d33-4784-bdef-f37b8fce42c1" class="">【递归和循环】7. 斐波那契数列</h3><p id="f8b1b8eb-fde1-4584-91b5-37142399ecf9" class="">大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）  n&lt;=39</p><p id="4e15657e-ae43-4f75-a7cc-b2857a36d167" class=""><strong>题解</strong></p><p id="3ef855d4-eaf4-4f60-bd5b-b1b52376a51c" class="">迭代（Iteration） 会重复计算</p><pre id="51f11522-2cc3-46b4-8c65-def52d6e6a3d" class="code"><code># 时间复杂度：O(n)   空间复杂度：O(1)
class Solution:
    def Fibonacci(self, n):
        # write code here
        a = 0
        b = 1
        if n &lt;= 1:
            return n
        for i in range(n):
            a ,b = b,b+a            
        return a</code></pre><h3 id="667f31ee-3e71-4fd6-929d-5e3e3f507a8c" class="">【递归和循环】8. 跳台阶</h3><p id="3d5a12ad-7316-428b-91d6-e5ae5ee485d4" class="">一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）</p><p id="3960190e-07fe-4e02-a719-bd780ea634c3" class=""><strong>题解：中心思想就是</strong><mark class="highlight-red_background"><strong>F(N)=F(N-1)+F(N-2)</strong></mark></p><ul id="52eb914e-e438-437d-b771-67af3817f47c" class="bulleted-list"><li>常规递归解法<mark class="highlight-red_background"><strong>F(N)=F(N-1)+F(N-2)</strong></mark>，时间复杂度太过于昂贵 O(2^n)</li></ul><ul id="2b3f5784-d6ec-4611-9bd7-0aee5e2bb608" class="bulleted-list"><li>Fibonacci数列（迭代） O(n)<pre id="4897b1ad-f595-4fc4-b4c8-88a44e575604" class="code"><code># 递归：O(2^n)
def jumpFloor(number):
		if number &lt;= 0:
				return
		elif number == 1:
				return 1
		elif number == 2:
				return 2
		res = 0
		res = res + jumpFloor(number-1) + jumpFloor(number-2)
		return res

# Fibonacci数列：O(n)
class Solution:
    def jumpFloor(self, number):
        # write code here
				# 也可以初始化l=1，r=2，然后loop in range（number-1），可以cover n从1到n的情况
        l = 0
        r = 1
        for _ in range(number):
            l,r = r,l+r
        return r</code></pre></li></ul><ul id="4ab907f8-95e7-483f-b7ad-1e54dd50f684" class="bulleted-list"><li>二阶递推数列，可用矩阵乘法的形式表示  O(logN)<p id="c8542651-9768-4e31-ad3e-5514acc6b4da" class="">状态矩阵为2x2的矩阵：</p><figure id="c317bf07-e075-41c4-ac50-e96a0e0b63c1" class="equation"><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css')</style><div class="equation-container"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>)</mo><mo>=</mo><mo>(</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo separator="true">,</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>)</mo><mo>×</mo><mrow><mo fence="true">∣</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>b</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>d</mi></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">(F(n),F(n-1))=(F(n-1),F(n-2))\times\begin{vmatrix} a &amp; b \\ c &amp; d  \end{vmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.424em;vertical-align:-0.9500199999999999em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.47398em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26198em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47398em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.47398em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26198em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47398em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span></span></span></span></span></div></figure><p id="47efe1dd-2b02-44ed-9c94-c917085ac0af" class="">代入F(1)=1, F(2)=2, F(3)=3, F(4)=5 得</p><figure id="e82da6bb-a03f-4ed8-b3b1-7099696eedbb" class="equation"><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css')</style><div class="equation-container"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mo fence="true">∣</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>b</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>d</mi></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><mo>=</mo><mrow><mo fence="true">∣</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{vmatrix} a &amp; b \\ c &amp; d  \end{vmatrix}=\begin{vmatrix} 1 &amp; 1 \\ 1 &amp; 0  \end{vmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.424em;vertical-align:-0.9500199999999999em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.47398em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26198em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47398em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.47398em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26198em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47398em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.424em;vertical-align:-0.9500199999999999em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.47398em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26198em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47398em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.47398em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26198em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47398em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span></span></span></span></span></div></figure><p id="20205951-5299-4082-9425-69b3a229e80d" class="">n&gt;2时，公式可简化为</p><figure id="74263aac-783d-4962-ad83-aadf7fb53310" class="equation"><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css')</style><div class="equation-container"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>(</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo>)</mo><mo>=</mo><mo>(</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>)</mo><mo separator="true">,</mo><mi>F</mi><mo>(</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>)</mo><mo>)</mo><mo>×</mo><mrow><mo fence="true">∣</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><mo>=</mo><mo>(</mo><mn>2</mn><mo separator="true">,</mo><mn>1</mn><mo>)</mo><mo>×</mo><msup><mrow><mo fence="true">∣</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">∣</mo></mrow><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">(F(n),F(n-1))=(F(n-1),F(n-2))\times\begin{vmatrix} 1 &amp; 1 \\ 1 &amp; 0  \end{vmatrix}=(2,1)\times\begin{vmatrix} 1 &amp; 1 \\ 1 &amp; 0  \end{vmatrix}^{n-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.424em;vertical-align:-0.9500199999999999em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.47398em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26198em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47398em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.47398em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26198em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47398em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.6280080000000003em;vertical-align:-0.9500199999999999em;"></span><span class="minner"><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.47398em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26198em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47398em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.47398em;"><span style="top:-1.65598em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.26198em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-2.86798em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span><span style="top:-3.47398em;"><span class="pstrut" style="height:2.606em;"></span><span class="delimsizinginner delim-size1"><span>∣</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500199999999999em;"><span></span></span></span></span></span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.6779880000000003em;"><span style="top:-3.9268800000000006em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></span></div></figure><p id="ece29429-c7ec-463b-aaf3-f91a29f305fc" class="">变成了求解矩阵N次方的问题</p><pre id="0916e135-b4f4-4345-a3a2-1e1b06acb6f1" class="code"><code>class Solution:
    def jumpFloor(self, number):
        # write code here
        def matrixPower(m, p):
						# 单位矩阵
            res = [[0 if i != j else 1 for i in range(len(m[0]))] for j in range(len(m))]
            tmp = m
            while p &gt; 0:
                if p &amp; 1 != 0:
                    res = muliMatrix(res, tmp)
                tmp = muliMatrix(tmp, tmp)
                p &gt;&gt;= 1
            return res

        def muliMatrix(m1, m2):
            res = [[0 for i in range(len(m2[0]))] for j in range(len(m1))]
            for i in range(len(m1)):
                for j in range(len(m2[0])):
                    for k in range(len(m1[0])):
                        res[i][j] += m1[i][k] * m2[k][j]
            return res

        if number &lt; 1:
            return 0
        if number == 1 or number == 2:
            return number
        base = [[1,1],[1,0]]
        res = matrixPower(base, number-2)
        return 2*res[0][0] + res[0][1]</code></pre></li></ul><h3 id="017707ee-9242-43bc-8174-62ed2135205b" class="">【递归和循环】9. 变态跳台阶</h3><p id="22f25097-d907-4627-ae9b-edeb1a093728" class="">一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p id="68262757-f5ca-4a36-b4a5-509b8e72e241" class=""><strong>题解</strong></p><p id="1e441502-da81-4e00-87f2-43e1de73bbbf" class="">观察规律可得2^(n-1)</p><p id="f547d93c-ab15-40fd-81cb-c00eafc26677" class="">两种解释：</p><ul id="a771de56-7d1f-4b6d-9440-6b169a1cf5d3" class="bulleted-list"><li>每个台阶可以看作一块木板，让青蛙跳上去，n个台阶就有n块木板，最后一块木板是青蛙到达的位子， 必须存在，其他 (n-1) 块木板可以任意选择是否存在，则每个木板有存在和不存在两种选择，(n-1) 块木板 就有 [2^(n-1)] 种跳法，可以直接得到结果。</li></ul><ul id="e3c0a1dc-209d-4658-8ce0-7c1a1c157d00" class="bulleted-list"><li>因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级 跳1级，剩下n-1级，则剩下跳法是f(n-1) 跳2级，剩下n-2级，则剩下跳法是f(n-2) 所以f(n)=f(n-1)+f(n-2)+...+f(1) 因为f(n-1)=f(n-2)+f(n-3)+...+f(1)<p id="75c720c3-2374-4e0c-a34c-85597612cdcc" class="">所以f(n)=2*f(n-1)</p></li></ul><pre id="26f1416a-e8d4-4635-97ed-e488f3f1c964" class="code"><code># 常规
class Solution:
    def jumpFloorII(self, number):
        # write code here
        if number &lt; 1:
            return 0
        else:
            return 2**(number-1)
# 移位
return  1&lt;&lt;--number-1</code></pre><h3 id="d35be7db-53e9-4884-ab18-0eba8a539894" class="">【递归和循环】10. 矩形覆盖</h3><p id="4106b1c3-1066-4c6d-a222-404a4df91f37" class="">我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p id="a2719b12-90e1-4822-b5b9-d87311929d1b" class=""><strong>题解</strong></p><p id="98b3f2f0-144c-4ab2-b6f8-f3a4272250d4" class="">Fibonacci数列</p><figure id="c6ce05f5-1b2b-49f7-a841-de49d737d562" class="image"><a href="Offer/Untitled%202.png"><img style="width:624px" src="Offer/Untitled%202.png"/></a></figure><pre id="793c1e6c-1684-4f35-a801-17b6721d1510" class="code"><code>class Solution:
    def rectCover(self, number):
        # write code here
        if number &lt; 1:
            return 0
        else:
            l=1
            r=2
            for _ in range(number-1):
                l,r = r,l+r #(或者r+l也是一样的)
            return l</code></pre><h3 id="8cbf934c-6f32-4e3c-a02b-33ff82376e41" class="">【位运算】11. 二进制中1的个数</h3><p id="847461a9-a735-493b-80e1-07cec480eb6e" class="">输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p id="8a247bb0-861f-49d1-b9d8-c0fed052fa15" class=""><strong>题解</strong></p><p id="4c2554a5-ca09-45f5-bc49-a1a0257a6c01" class="">如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p><p id="ca4d2356-d1e1-4def-8dee-04420fbb1c1d" class="">举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如<strong>1100&amp;1011=1000</strong>.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p><div id="f6f811ca-1581-4169-81b5-14f9313ad414" class="column-list"><div id="5f166172-21f0-4dbb-a87c-6c0ab3ac303e" style="width:75%" class="column"><pre id="18bc5535-5eec-4939-bec3-0fc64584bfbe" class="code"><code>class Solution:
    def NumberOf1(self, n):
        # write code here
        count = 0
        if n &lt; 0:
						# Python需要与0xffffffff位与才能变成补码形式
            n = n &amp; 0xffffffff
        while n:
            count += 1
            <mark class="highlight-red_background">n = (n - 1) &amp; n #二进制经典 与 操作</mark>
        return count
# python带的一个bin()方程
		def NumberOf1(n):
				if n &gt;= 0:
            bi = bin(n)
        else:
            bi = bin(n &amp; 0xffffffff)
        return bi.count(&#x27;1&#x27;)</code></pre></div><div id="a91f6a53-788e-47ec-868b-8b469112a7e8" style="width:25%" class="column"><pre id="b5deaba9-b05d-419c-bbd7-3a9f9f462d1a" class="code"><code>1<del>1</del>00 &amp; 1011 = 1000

1100和1011之间的关系：
1100-1=1011
12 11

0+0=0 0+1=1 1+1=10

0 0
1 1
2 10
3 11
4 100
5 101
6 110
7 111
8 1000
9 1001
10 1010

 11
+ 1
---
100</code></pre></div></div><h3 id="df220ed0-3109-4fe7-83cc-01671d0178d0" class="">【代码的完整性】12. 数值的整数次方</h3><p id="bef80523-c95b-4a31-9458-7a60f0fa6b74" class="">给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p id="86630882-e8e7-4f6a-824c-a696f9939268" class="">保证base和exponent不同时为0</p><p id="17a0a729-55d4-48e2-80f3-7e8fdbb81d81" class=""><strong>题解</strong></p><figure id="0aa606fe-c059-4981-a168-46c7f7f7f112"><a href="https://blog.csdn.net/hkdgjqr/article/details/5381028" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">快速求幂算法_hkdgjqr的专栏-CSDN博客</div><div class="bookmark-description">直接乘要做998次乘法。但事实上可以这样做，先求出2^k次幂： 3 ^ 999= 3 ^ (512 + 256 + 128 + 64 + 32 + 4 + 2 + 1)= (3 ^ 512) * (3 ^ 256) * (3 ^ 128) * (3 ^ 64) * (3 ^ 32) * (3 ^ 4) * (3 ^ 2) * 3 这样只要做16次乘法。即使加上一些辅助的存储和运算，也比直接乘高效得多（尤其如果这里底数是成百上千位的大数字的话）。 我们发现，把999转为2进制数：1111100111，其各位就是要乘的数。这提示我们利用求二进制位的算法（其中mod是模运算）： 这个算法给出正整数n的反向二制进位，如6就给出011（6的二进制表示为110）。事实上这个算法对任意的p进制数是通用的，只要把其中的2换成p就可以了。 如何把它改编为求幂运算？我们发现这个算法是从低位向高位做的，而恰好我们求幂也想从低次幂向高次幂计算（参看前面的例子）。而且我们知道前面求出的每个2^k次幂只参与一次乘法运算，这就提示我们并不把所有的中间结果保存下来，而是在计算出它们后就立即运算。于是，我们要做的就是把输出语句改为要做的乘法运算，并在n减少的同时不断地累积求2^k次幂。 http://acm.pku.edu.cn/JudgeOnline/problem?id=3134</div></div><div class="bookmark-href"><img src="https://csdnimg.cn/public/favicon.ico" class="icon bookmark-icon"/>https://blog.csdn.net/hkdgjqr/article/details/5381028</div></div><img src="https://img-blog.csdnimg.cn/20190918140012416.png" class="bookmark-image"/></a></figure><figure id="24d7b52f-0c97-4708-be30-3a67a3bbb603" class="image"><a href="Offer/Untitled%203.png"><img style="width:2222px" src="Offer/Untitled%203.png"/></a></figure><pre id="a13e17cb-412a-4266-8ead-88c9f13d1f61" class="code"><code># 暴力连乘：时间复杂度是 O(N),空间复杂度是 O(1)
class Solution:
    def Power(self, base, exponent):
        # write code here
        t = 1
        if exponent == 0:
            return 1
        elif exponent &gt; 0:
            for i in range(exponent):
                t*=base
        else:
            for i in range(-exponent):
                t/=base
        return t
<mark class="highlight-red_background"><strong># 快速幂算法</strong></mark>
class Solution:
    def fast_power(self, base, exponent):
<strong>				# 永远第一时间补上特殊情况
        if base == 0:
            return 0
        if exponent == 0:
            return 1
				# coding开始</strong>
        e = abs(exponent)
        tmp = base
        res = 1
        while(e &gt; 0):
            #如果最后一位为1，那么给res乘上这一位的结果（&amp;判断e的奇偶，e为偶结果为0；e为奇结果为1）
            if <mark class="highlight-red_background">e%2 == 1</mark>: # e&amp;1是一个二进制 与 的操作比较
                res = res * tmp
            # 符号&gt;&gt;代表e/(2^1)的整数部分，找整除数
						e = <mark class="highlight-red_background">e//2</mark>
            tmp = tmp * tmp
        return res if exponent &gt; 0 else 1/res
3**100
100 = 2^6+2^5+2^2
3^(64+32+4)

&gt;&gt; 向右位移
bin(100):&#x27;0b1100100&#x27; # 1出现的位置就是需要res保存进去的位置
bin(50): &#x27;0b110010&#x27;
bin(25): &#x27;0b11001&#x27;

	e 100 -&gt; 50  -&gt; 25  -&gt; 12  -&gt; 6    -&gt; 3    -&gt; 1        -&gt; 0
tmp 3   -&gt; 3^2 -&gt; 3^4 -&gt; 3^8 -&gt; 3^16 -&gt; 3^32 -&gt; 3^64     -&gt; 3^128 #tmp初始值是base 3
res 1   -&gt; 1   -&gt; 1   -&gt; 3^4 -&gt; 3^4  -&gt; 3^4  -&gt; 3^(4+32) -&gt; 3^(4+32+64)</code></pre><h3 id="b06c48b8-4eeb-462f-9e71-9d9edf751e54" class="">【代码的完整性】13. 调整数组顺序使奇数位于偶数前面</h3><p id="494c9824-64f4-4f72-a94f-596caee1d894" class="">输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p id="87d0e08d-7f11-40f7-a05d-b47fde793875" class=""><strong>题解</strong></p><pre id="ce396d26-6475-4843-8da0-56d98172c33e" class="code"><code># 新建数组 时间复杂度为O(n)，空间复杂度为O(n)
class Solution:
    def reOrderArray(self, array):
        # write code here
        o=[]
        e=[]
        for i in array:
            if i%2 == 1:
                o.append(i)
            else:
                e.append(i)
        return o+e
<strong><mark class="highlight-red_background"># lambda表达式</mark></strong>
def reOrderArray(array):
		return sorted(array,key=lambda c:c%2,reverse=True)
<strong><mark class="highlight-red_background"># 类似冒泡算法，前偶后奇数交换</mark></strong>
def reOrderArray(array):
    # write code here
    for i in range(len(array)):
        for j in <mark class="highlight-red_background"><strong>range(len(array)-1,i,-1)</strong></mark>: #j为顺序10，9，8，……，i这样的数
            if array[j]%2 == 1 and array[j-1]%2 == 0: #前一个是奇数，后一个是偶数
                array[j],array[j-1]=array[j-1],array[j]
    return array</code></pre><h3 id="2ef0efbb-3939-4240-b7dd-9946b123c773" class="">【代码的鲁棒性】14. 链表中倒数第k个结点</h3><p id="f09fc5a6-2555-45ec-81c5-181c8b162e6a" class="">输入一个链表，输出该链表中倒数第k个结点。</p><p id="476b4116-d02a-4cf5-b085-10476e8facf0" class=""><strong>题解</strong></p><ul id="2e46de09-5232-4a7c-ab5a-82a2d7af6f40" class="bulleted-list"><li>用list存住链表值</li></ul><ul id="9d53f588-490c-48b6-bdcb-15e8ee70d686" class="bulleted-list"><li>设置两个指针，p1，p2，先让p1走k-1步，然后再一起走，直到p1为最后一个时，p2即为倒数第k个节点</li></ul><pre id="ef55097e-daea-4bff-8c25-18600fb0c3f5" class="code"><code># 创一个list存起来
class Solution:
    def FindKthToTail(self, head, k): #这里head就是listnode的head，可以直接用head.next得到下一个点
        # write code here
<mark class="highlight-red_background">        if len(temp)&lt;k or k&lt;1: #一直都还是要考虑空值/异常情况
            return</mark>
        temp=[]
        while head:
            temp.append(head)
            head=head.next #访问下一个节点用next，取值用va
        return temp[-k]
<mark class="highlight-red_background"><strong># 双指针</strong></mark>
class Solution:
    def FindKthToTail(self, head, k):
        # write code here
<mark class="highlight-red_background">        if head==None or k&lt;1: #一直都还是要考虑空值
            retur</mark>
        p1=head
        p2=head
        for _ in range(k): #所以p1在实际中走k步，比理论多走一步
            if p1==None:
                return
            p1=p1.next #理论：先让p1走k-1步
        while p1: #因为p1需要走到None，所以要在上面多走一步
            p1=p1.next
            p2=p2.next
        return p2</code></pre><h3 id="8bdb9cda-943d-4e18-9624-c4e30663b18a" class="">【代码的鲁棒性】15. 反转链表</h3><p id="479c42ec-e3a5-40a2-b868-92c4ce3d4f36" class="">输入一个链表，反转链表后，输出新链表的表头。</p><p id="f9f16256-f834-4be9-ba18-335abf7d2710" class=""><strong>题解</strong></p><p id="bb514596-4b19-4c10-a4ae-3c4c093af9f1" class=""><mark class="highlight-red_background"><strong>三指针实现</strong></mark>：1-&gt;2-&gt;3-&gt;4-&gt;5，遍历链表，把1的next置为None，2的next置为1，以此类推，5的next置为4。得到反转链表。需要考虑链表只有1个元素的情况。图中有具体的每步迭代的思路，最后输出pre而不是cur是因为最后一次迭代后cur已经指向None了，而pre是完整的反向链表。</p><div id="0897f2f8-0f3c-48f9-a893-3a86af567539" class="column-list"><div id="788227f7-6dc8-4bb8-bf9d-473ca0b017ab" style="width:62.5%" class="column"><pre id="6b52f226-342e-4481-a9b1-873df41b56ff" class="code"><code>class Solution:
    # 返回ListNode
    def ReverseList(self, pHead):
        # write code here
        if pHead == None <strong><mark class="highlight-red_background">or pHead.next == None:
				#None的情况要考虑完整</mark></strong>
            return pHead #如果链表只有一个值就只能直接phead，所以不能写return None
        pre = None
        cur = pHead
        while cur:
            tmp = cur.next #先用一个tmp保持cur.next 
            cur.next = pre #反指针设定尾巴为pre
            pre = cur #反指针cur的头重新赋予pre，这样pre就拥有上一个cur.next的反指针尾巴内容
            cur = tmp #再把tmp重新返回给cur，继续下一个循环
        return pre</code></pre></div><div id="f233f050-df27-49dd-b4e6-5145c5e000b5" style="width:37.5%" class="column"><figure id="e7c706e2-cbed-4f39-bbab-d611a825516d" class="image"><a href="Offer/Untitled%204.png"><img style="width:288px" src="Offer/Untitled%204.png"/></a></figure></div></div><h3 id="e72a749b-e1b9-44b9-8651-6d98e40c7483" class="">【代码的鲁棒性】16. 合并两个排序的链表 — 重复比较的话应该往递归想</h3><p id="bbcf2174-3226-4cfd-b695-27779f7db24e" class="">输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p id="c44a5046-b6fe-4874-8b6e-655163ca4a8d" class=""><strong>题解</strong></p><figure id="a3d94650-b576-48b5-8ff1-0c33f37cd3cb" class="image"><a href="Offer/Untitled%205.png"><img style="width:288px" src="Offer/Untitled%205.png"/></a></figure><pre id="8571af23-940a-4fd0-a8f4-00792659e9e5" class="code"><code># 非递归版本
class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        # write code here
        oHead = ListNode(None)
        res = oHead
        while pHead1 and pHead2:
            if pHead1.val &gt;= pHead2.val:
                oHead.next = pHead2
                pHead2 = pHead2.next
            else:
                oHead.next = pHead1
                pHead1 = pHead1.next
            oHead = oHead.next
        if pHead1:
            oHead.next = pHead1
        elif pHead2:
            oHead.next = pHead2
        return res.next
<strong><mark class="highlight-red_background"># 递归版本</mark></strong>
class Solution:
    # 返回合并后列表
    def Merge(self, pHead1, pHead2):
        # write code here
        if pHead1 is None:
            return pHead2
        if pHead2 is None:
            return pHead1
        if pHead1.val &lt; pHead2.val:
            <mark class="highlight-red_background">pHead1.next = self.Merge(pHead1.next, pHead2)</mark>
            return pHead1
        else:
            pHead2.next = self.Merge(pHead1, pHead2.next)
            return pHead2</code></pre><h3 id="067e9209-4243-49a3-9b9e-367c2ab5797d" class="">*【代码的鲁棒性】17. 树的子结构</h3><p id="3a999353-3010-4c93-bf2a-0e4d0cd092e0" class="">输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><p id="836031cd-38c0-4ec8-9ad3-faf16d4e57b6" class=""><strong>题解</strong></p><ol id="1a1e91d6-3b5c-46d7-85e4-bfdf08a3337e" class="numbered-list" start="1"><li>在树A中找到和B的根结点的值一样的节点R<p id="fe932870-7e53-4b9b-ad32-9745e10206f5" class="">查找树中的值，即为<strong><mark class="highlight-red_background">树的遍历。可用递归的方法</mark></strong>，也可以用循环的方法。因为递归的代码简洁，所以一般使用递归的方式。</p></li></ol><ol id="b6da753a-3b9c-4162-95b8-af164518092f" class="numbered-list" start="2"><li>判断A中以R为根结点的子树是不是包含和树B一样的结构</li></ol><pre id="c28b1180-a8e5-4714-a819-5cccf4754a19" class="code"><code>class Solution:
    # 遍历树A
		def HasSubtree(self, pRoot1, pRoot2):
        # write code here
        result = False
        if pRoot1 and pRoot2: # 经常会用if A and B去判断是否还有内容
            if pRoot1.val == pRoot2.val:
                result = self.IsSubtree(pRoot1,pRoot2)
            if not result:
                result = self.HasSubtree(pRoot1.left,pRoot2) or self.HasSubtree(pRoot1.right,pRoot2)
        return result
    # IsSubtree用于递归判断树的<mark class="highlight-orange_background">每个节点是否相同</mark>
		# 前两个if语句不可以颠倒顺序：如果2已经遍历完成，那么为True；颠倒的话会先判断1为None
		def IsSubtree(self, pRoot1, pRoot2):
        if pRoot2 == None: #如果root2先遍历完成发现都满足，那就是true
            return True
        if pRoot1 == None:
            return False
        if pRoot1.val != pRoot2.val:
            return False
        return self.IsSubtree(pRoot1.left,pRoot2.left) and self.IsSubtree(pRoot1.right,pRoot2.right)</code></pre><h3 id="5fa19299-8135-459b-9b95-18b15c5d5357" class="">【面试思路】18. 二叉树的镜像</h3><p id="33d6bc8b-9f0a-40ec-881c-9b3aa6f35cc5" class="">操作给定的二叉树，将其变换为源二叉树的镜像。</p><p id="ede90dd0-610d-4a01-840a-9fe080bc4cb7" class=""><strong>题解</strong></p><div id="8eb22df2-4c14-4567-ac89-1a3fecaa331d" class="column-list"><div id="26a459de-2836-45d9-8571-fe65ee16acc4" style="width:62.5%" class="column"><pre id="2964ff06-71a0-4b26-8d20-3c6ee485670b" class="code"><code>class Solution:
    # 返回镜像树的根节点
    def Mirror(self, root):
        # write code here
        if root == None:
            return root #或者None也可以
        # 交换左右子树
				tmp = root<mark class="highlight-red_background"><strong>.left</strong></mark>
        root.left = root<mark class="highlight-red_background"><strong>.right</strong></mark>
        root.right = tmp
				<mark class="highlight-orange_background"># 递归</mark>
        self.Mirror(root.left)
        self.Mirror(root.right)</code></pre></div><div id="132ea6ce-2bd3-493f-a665-dd6b8a2eb0df" style="width:37.5%" class="column"><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="6e540f70-e5c2-4651-85a0-1bbcb974d3ef"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">        源二叉树
    	    8
    	   /  \
    	  6   10
    	 / \  / \
    	5  7 9 11
    	镜像二叉树
    	    8
    	   /  \
    	  10   6
    	 / \  / \
    	11 9 7  5</div></figure></div></div><h3 id="e0e3f231-fc67-4345-8b16-20546d4af4ef" class="">【画图让抽象形象化】19. 顺时针打印矩阵</h3><p id="2558080a-6b46-4598-833d-0a85c57b7328" class="">输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><p id="e8dbe9df-1d62-494e-8f9f-6a89f41d5cae" class=""><strong>题解</strong></p><ul id="ac24b490-a2ab-45e2-9760-2536a1a01f98" class="bulleted-list"><li>外圈 → 内圈</li></ul><ul id="fcabd3c9-81e9-4414-a157-146ff6259438" class="bulleted-list"><li>魔方逆时针旋转</li></ul><div id="460cc27a-7189-429e-92ae-aeab1c8a2b29" class="column-list"><div id="35b3406f-2cec-4bb8-a287-0c372b7a4267" style="width:50%" class="column"><figure id="2c01fbd2-6462-4d03-a5ee-4b3bf56e0f3a" class="image"><a href="Offer/Untitled%206.png"><img style="width:240px" src="Offer/Untitled%206.png"/></a><figcaption>外圈到内圈</figcaption></figure></div><div id="123c49d1-bbbb-4e4e-af66-2eb9c48781ec" style="width:50%" class="column"><p id="f88a8ffd-b6de-43b5-9709-4f2ea48f5594" class="">1 2 3</p><p id="cca431cd-6ad8-43d3-8b98-8ec73e100741" class="">4 5 6</p><p id="a5c8a0f3-ab86-491f-8610-02e51fdd2136" class="">7 8 9</p><p id="3862933b-d29c-458a-bfe4-b39e05d73f69" class="">删除第一行后，逆时针旋转</p><p id="0d281bea-85f8-4b61-a3d8-71f27d7da55c" class="">6 9</p><p id="e4059305-c7a5-4643-a861-fe44749cc920" class="">5 8</p><p id="896537df-06f5-4511-8585-828621d1963c" class="">4 7</p></div></div><pre id="83f40398-eed1-45fe-adad-124a37fb1ed5" class="code"><code># 魔方逆时针旋转1
class Solution:
    # matrix类型为二维列表，需要返回列表
    def printMatrix(self, matrix):
        result = []
        while(matrix):
						# 加上最上方一行
            result+=matrix.pop(0)
            if not matrix or not matrix[0]:
                break
            matrix = self.turn(matrix)
        return result
    def turn(self,matrix):
        num_r = len(matrix)
        num_c = len(matrix[0])
        newmat = []
        for i in range(num_c):
            newmat2 = []
            for j in range(num_r):
                newmat2.append(matrix[j][i])
            newmat.append(newmat2)
        newmat.reverse()
        return newmat
# 魔方逆时针旋转2
class Solution:
    def printMatrix(self, matrix):
        res = []
        while matrix:
            res += matrix.pop(0)
            if matrix and matrix[0]:
                for row in matrix:
                    res.append(row.pop()) #这个是把右边的值打出来
            if matrix:
                res += matrix.pop()[::-1] #这个是最后一行
            if matrix and matrix[0]:
                for row in matrix[::-1]: #这个是左边的值
                    res.append(row.pop(0))
        return res
#Mia的解答~~~~
class Solution:
	def printMatrix(self, matrix):
	        if matrix == None:
	            return None
	        if len(matrix) == 1:
	            return matrix[0]
	        if len(matrix[0]) == 1:
	            return [i[0] for i in matrix]
	        if len(matrix[0])%2==0: k = len(matrix[0])/2
	        else: k=(len(matrix)+1)/2
	        n = 1
	        new = []
	        while n &lt;= k:
	            if len(matrix) &gt; 1:
	                for j in range(2*len(matrix)-2):
	                    if j == 0:
	                        new.extend(matrix[j])
	                    elif j &lt; len(matrix)-1:
	                        new.append(matrix[j][-1])
	                    elif j == len(matrix)-1:
	                        new.extend(matrix[j][::-1])
	                    else:
	                            new.append(matrix[j-2*(j-len(matrix)+1)][0])
	            else:
	                new.extend(matrix[0])
	            matrix = [i[1:-1] for i in matrix[1:-1]]
	            n += 1
	        return new</code></pre><h3 id="54f02586-2f6b-4751-bc62-70180b4afd4f" class="">【举例让抽象具体化】20. 包含min函数的栈</h3><p id="b226fefc-e429-42f9-9d86-ed6d16bb7116" class="">定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数<mark class="highlight-yellow_background"><strong>（时间复杂度应为O（1））。</strong></mark></p><p id="dc3ed707-7f39-46f6-8bc1-09f9e6f1e49f" class=""><strong>题解</strong></p><p id="4236f5c7-6389-48ca-8bcc-0f55d25203a1" class="">创建一个辅助栈，每次把最小元素压入。可以保证data的最小值一直在辅助栈的顶端</p><pre id="cf5fcdba-a0c6-4a23-93f2-82383f573b90" class="code"><code>class Solution:
    def __init__(self):
        self.datastack = []
        self.minstack = []
    def push(self, node): #只需要加node 不需要return
        self.datastack.append(node)
        if self.minstack:
            self.minstack.append(min(node,self.minstack[-1]))
        else:
            self.minstack.append(node)
    def pop(self):
        if self.datastack:
            self.minstack.pop() #也需要同样在minstack pop一个出来
            return self.datastack.pop()
    def top(self): #出栈
        if self.datastack:
            return self.datastack[-1] #需要返回一个值
    def min(self): # 注意题目条件时间复杂度要求是1
        if self.datastack:
            return self.minstack[-1]</code></pre><h3 id="880f00fd-37ec-4517-91db-358b7dcfaf6e" class="">*【举例让抽象具体化】21. 栈的压入、弹出序列</h3><p id="b1f1bfec-1eda-4f05-8a2d-04e43b8bb69a" class="">输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><p id="2bfc0ae8-cf42-4ac0-88cf-360d2997d638" class=""><strong>题解</strong></p><p id="ae6b66d4-c57c-40c7-81aa-8afe90ef39dd" class="">借用一个<strong>辅助的栈</strong>，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p><pre id="bd44127b-5d5d-4721-a068-b2eb6dedc673" class="code"><code>举例：
入栈1,2,3,4,5
出栈4,5,3,2,1
首先1入辅助栈，此时栈顶1≠4，继续入栈2
此时栈顶2≠4，继续入栈3
此时栈顶3≠4，继续入栈4
此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3
此时栈顶3≠5，继续入栈5
此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</code></pre><pre id="796223ed-11b9-47b0-b382-70d613f1ecb7" class="code"><code>class Solution:
    def IsPopOrder(self, pushV, popV):
        # stack中存入pushV中取出的数据
				stack = []
        while popV:
            # 如果stack的最后一个元素与popV中第一个元素相等，将两个元素都弹出
						if stack and stack[-1] == popV[0]:
                stack.pop()
                popV.pop(0)
            # 如果pushV中有数据，压入stack
						elif pushV: #要遍历pushV
                stack.append(pushV.pop(0))
            # 上面情况都不满足，直接返回false
						else: #pushV已经全部进去辅助栈，且辅助栈最后一个跟popV[0]也不相等
                return False
        return True</code></pre><h3 id="aff456bb-c9e0-471b-b6ce-f3e6327f10e0" class="">【队列实现BFS】22. 从上往下打印二叉树</h3><p id="1183e3d6-2c67-40cf-83b7-cce3aae62cc9" class="">从上往下打印出二叉树的每个节点，<strong>同层节点从左至右打印</strong>。</p><p id="d474208a-4464-4d7d-acec-49b03ac92a85" class=""><strong>题解</strong></p><p id="688bbb59-7261-40a5-9db8-99c47cc00eac" class="">广度优先搜索 BFS, 借助一个队列就可以实现（层次遍历）</p><figure id="a012410a-332c-47bf-b7c4-335b49ab9b08" class="image"><a href="Offer/Untitled%207.png"><img style="width:624px" src="Offer/Untitled%207.png"/></a></figure><pre id="441e0b3d-d8ea-4edb-910f-29a14586619c" class="code"><code>class Solution:
    # 返回从上到下每个节点值列表，例：[1,2,3]
    def PrintFromTopToBottom(self, root):
        if not root:
            return [] # none return结果根据题目具体而改
        res=[]
        queue=[]
        queue.append(root) 
        while len(queue)&gt;0:
            res.append(queue[0].val) #第一次循环root是8那个点
            if queue[0].left:
                queue.append(queue[0].left)
            if queue[0].right:
                queue.append(queue[0].right)
            queue.pop(0)
        return res</code></pre><h3 id="47c9982b-e8d3-4248-bb88-9f0c83eeafbb" class="">*【举例让抽象具体化】23. 二叉搜索树的后序遍历序列</h3><p id="5f7d519a-3193-4134-8976-4fbbc76a5aee" class="">输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><p id="86b700ab-7cc0-435a-ac14-7b76d78e60b0" class=""><strong>题解</strong></p><p id="87907384-ccd5-44e5-b99d-e95f71b53637" class="">递归：BST的后序序列的合法序列是，对于一个序列S，<strong>最后一个元素是x （也就是根）</strong>，如果去掉最后一个元素的序列为T，那么T满足：T可以分成两段，前一段（左子树）小于x，后一段（右子树）大于x，且这两段（子树）都是合法的后序序列。</p><figure class="block-color-orange callout" style="white-space:pre-wrap;display:flex" id="01d1fc84-d213-4cf4-a6ec-8a1041147df4"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%"> BTS的性质：右&gt;根&gt;左</div></figure><pre id="55f0f47b-6622-45ba-990d-49579f3924b9" class="code"><code>class Solution:
    def VerifySquenceOfBST(self, sequence):
        if not sequence or len(sequence)&lt;=0:
            return False
        # 左子树
        for i in range(len(sequence)):
            if sequence[i] &gt; sequence[-1]:
                break
        # 右子树
        for j in range(i,len(sequence)): #range from i to len(sequence)!
            if sequence[j] &lt; sequence[-1]: #不是小于等于，等于很可能在走到最后一个点的时候就return False
                return False
        res1=True
        if i&gt;0: #排除i为0
            res1=self.VerifySquenceOfBST(sequence[0:i])
        res2=True
        if i&lt;len(sequence)-1:
            res2=self.VerifySquenceOfBST(sequence[i:-1])
        return res1 and res2</code></pre><h3 id="acef3064-13b4-499b-9b76-9e8fe79daac7" class="">*【举例让抽象具体化】24. 二叉树中和为某一值的路径</h3><p id="d09c48fb-dc41-40c3-a1af-c19ef3a3caed" class="">输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><p id="a65835bb-ad2e-4e4d-bccc-858e0d0ce5d3" class=""><strong>题解</strong></p><p id="d1b6e71f-db82-4777-b6e4-b5640d7bd13c" class="">非递归法：后序遍历</p><ol id="f68c11e2-e639-44bc-a2a3-9f03a473f809" class="numbered-list" start="1"><li>进栈时候，把值同时压入路径的向量数组，修正路径的和</li></ol><ol id="61d78e2c-b263-4cf2-a216-425baf798832" class="numbered-list" start="2"><li>出栈时候，先判断和是否相等，且该节点是否是叶节点，判断完成后保持和栈一致，抛出路径，修改路径的和</li></ol><ol id="f81ead99-5657-4685-b4ef-90536c0fa51b" class="numbered-list" start="3"><li>向量数组和栈的操作要保持一致</li></ol><p id="5f664e12-19c0-4ad2-8c20-084b7c1448f1" class="">注意把一个列表加到另一个列表中作为另一个列表的元素，一定要这样写list2.append(list1[:])（<strong>浅拷贝</strong>），不然加的是空的，这涉及到Python的可变对象、不可变对象等机制</p><pre id="e49c63a2-1be0-4ade-82e1-c95d649d8923" class="code"><code>class Solution:
    # 返回二维列表，内部每个列表表示找到的路径
    def FindPath(self, root, expectNumber):
        res,val = [],[]
        def goPath(root):
            if root:
                val.append(root.val)
                if root.left==None and root.right==None and sum(val)==expectNumber:
                    res.append(val[:])
                else:
                    goPath(root.left)
                    goPath(root.right)
                val.pop()
        goPath(root)
        return res</code></pre><pre id="282561e1-8669-4509-8c62-befa4a8e2394" class="code"><code>#题外话：找所有路径 - DFS
class TreeNode:
    def __init__(self, value):
        self.val = value
        self.left = None
        self.right = None
 
class Solution:
    def binaryTreePaths(self, root):
        if root == None:
            return []
        result = []
        self.DFS(root, result, [root.val])
        return result
 
    def DFS(self, root, result, path):
        if root.left == None and root.right == None:
            result.append(path)
        if root.left != None:
            self.DFS(root.left, result, path + [root.left.val])
        if root.right != None:
            self.DFS(root.right, result, path + [root.right.val])</code></pre><h3 id="a65230cf-8d5a-4464-839a-dce25a5ae0d9" class="">【分解让复杂问题简单】25. 复杂链表的复制</h3><p id="fa1b29ef-e455-4c61-909b-b87fd3b03924" class="">输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><p id="ca98ef47-da72-48f0-95f8-9a2cd137aae1" class=""><strong>题解</strong></p><ul id="6337fb18-7e01-42e6-a079-331ebe81820f" class="bulleted-list"><li>递归法</li></ul><ul id="5366c76d-3838-4251-9552-56465949b229" class="bulleted-list"><li>哈希表</li></ul><ul id="d1d3e554-b209-40ac-956e-ea57d0c147f5" class="bulleted-list"><li>三步法</li></ul><p id="193d2cf6-d0da-4107-b354-0da3ec9c8e88" class="">1. 把复制的结点链接在原始链表的每一对应结点后面</p><figure id="7c3b5986-8601-4085-a997-48e587a761e3" class="image"><a href="https://uploadfiles.nowcoder.com/images/20160726/737942_1469488971641_84B136C6E4052690517046794A4F80B0"><img style="width:528px" src="https://uploadfiles.nowcoder.com/images/20160726/737942_1469488971641_84B136C6E4052690517046794A4F80B0"/></a></figure><p id="2b246a2a-a817-4582-8ea9-9e9d26ef324e" class="">2. 把复制的结点的random指针指向被复制结点的random指针的下一个结点</p><figure id="ef364203-6e83-4f1a-a2aa-3abd1e03c753" class="image"><a href="https://uploadfiles.nowcoder.com/images/20160726/737942_1469488996797_F052D5F977FA4E843FE926BA3200084A"><img style="width:528px" src="https://uploadfiles.nowcoder.com/images/20160726/737942_1469488996797_F052D5F977FA4E843FE926BA3200084A"/></a></figure><p id="0ef4868c-f928-42df-84d2-b0f7de882e55" class="">3. 拆分成两个链表，奇数位置为原链表，偶数位置为复制链表，注意复制链表的最后一个结点的next指针不能跟原链表指向同一个空结点None，next指针要重新赋值None(判定程序会认定你没有完成复制）</p><figure id="eb764cc0-130d-43d8-8e62-56ce5e38f437" class="image"><a href="https://uploadfiles.nowcoder.com/images/20160726/737942_1469489231960_95E2453212A43966E21F1ABC09A80999"><img style="width:528px" src="https://uploadfiles.nowcoder.com/images/20160726/737942_1469489231960_95E2453212A43966E21F1ABC09A80999"/></a></figure><pre id="27eb7121-2e6c-47ae-993b-8be3ab98e9a9" class="code"><code># -*- coding:utf-8 -*-
# class RandomListNode:
#     def __init__(self, x):
#         self.label = x
#         self.next = None
#         self.random = None

# 递归
class Solution:
    def Clone(self, head):
        if not head: return
        newNode = <mark class="highlight-red_background">RandomListNode(head.label)</mark>
        newNode.random = <mark class="highlight-red_background">head.random #任意指针</mark>
        newNode.next = self.Clone(head.next)
        return newNode

# 哈希表
class Solution:
    def Clone(self, head):
        nodeList = []     #存放各个节点
        randomList = []   #存放各个节点指向的random节点。没有则为None
        labelList = []    #存放各个节点的值

        while head:
            randomList.append(head.random)
            nodeList.append(head)
            labelList.append(head.label)
            head = head.next
        #random节点的索引，如果没有则为1   
        labelIndexList = map(lambda c: nodeList.index(c) if c else -1, randomList)

        dummy = RandomListNode(0)
        pre = dummy
        #节点列表，只要把这些节点的random设置好，顺序串起来就ok了。
        nodeList=map(lambda c:RandomListNode(c),labelList)
        #把每个节点的random绑定好，根据对应的index来绑定
        for i in range(len(nodeList)):
            if labelIndexList[i]!=-1:
                nodeList[i].random=nodeList[labelIndexList[i]]
        for i in nodeList:
            pre.next=i
            pre=pre.next
        return dummy.next

# 三步法
class Solution:
    # 返回 RandomListNode
    def Clone(self, pHead):
        if not pHead:
            return None
         
        dummy = pHead
         
        # first step, N&#x27; to N next
        while dummy:
            dummynext = dummy.next
            copynode = RandomListNode(dummy.label)
            copynode.next = dummynext
            dummy.next = copynode
            dummy = dummynext
         
        dummy = pHead
         
        # second step, random&#x27; to random&#x27;
        while dummy:
            dummyrandom = dummy.random
            copynode = dummy.next
            if dummyrandom:
                copynode.random = dummyrandom.next
            dummy = copynode.next
         
        # third step, split linked list
        dummy = pHead
        copyHead = pHead.next
        while dummy:
            copyNode = dummy.next
            dummynext = copyNode.next
            dummy.next = dummynext
            if dummynext:
                copyNode.next = dummynext.next
            else:
                copyNode.next = None
            dummy = dummynext
 
        return copyHead</code></pre><h3 id="f804fc6e-0963-47d8-ba18-04a193892011" class="">【分解让复杂问题简单】27. 字符串的排列</h3><p id="1f07ca38-32f3-4a9b-b35e-97ddc4bbf353" class="">输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p id="1447738d-d347-42fa-be2a-9434ea82a475" class=""><strong>题解</strong></p><ul id="24c3a123-3123-4bba-89f1-3671b33b0ce2" class="bulleted-list"><li>用递归的想法去做<figure id="67792c1e-6050-45b3-9b7b-63d680ddadf6" class="image"><a href="Offer/Untitled%208.png"><img style="width:528px" src="Offer/Untitled%208.png"/></a></figure></li></ul><ul id="09a48de4-b316-4d89-9162-98f8b39d1351" class="bulleted-list"><li>回溯法<p id="50cf85ae-441e-40ac-a9b6-5bb0bbdb8e3e" class="">利用树去尝试不同的可能性，不断地去字符串数组里面拿一个字符出来拼接字符串，当字符串数组被拿空时，就把结果添加进结果数组里，然后回溯上一层。（通过往数组加回去字符以及拼接的字符串减少一个来回溯。)</p><figure id="05dcfcec-5048-4f48-9464-c3d9e73c1282" class="image"><a href="Offer/Untitled%209.png"><img style="width:1288px" src="Offer/Untitled%209.png"/></a></figure></li></ul><pre id="4d4317a3-bd8f-4720-88a2-8f5baff8fce2" class="code"><code># 递归
class Solution:
    def Permutation(self, ss):
        if len(ss) &lt;= 1:
            return ss
        res = set() #用set避免重复
        for i in range(len(ss)):
						# 每一个j是Permutation(ss[:i]+ss[i+1:])这个list中不同排列组合的一个string
            for j in self.Permutation(ss[:i]+ss[i+1:]):
                res.add(ss[i]+j) #set用add
        return sorted(res)
# 回溯
class Solution:
    def Permutation(self, ss):
        if len(ss) &lt;= 1:
            return ss
        res=set()
        tmp=[]
				# 用一个dict记住每个单词出现次数
        n_dict = dict((x,0) for x in ss)
        for s in ss:
            n_dict[s]+=1
        self.Back(res,tmp,ss,n_dict)
        return sorted(list(res))
    def Back(self,res,tmp,ss,counter):
        if len(tmp) == len(ss):
            print(tmp)
            print(len(ss))
            res.add(&#x27;&#x27;.join(tmp))
        else:
            for i in ss:
                if counter[i] == 0:
                    continue
                # 用一次就减一，回溯时记得加回来
								counter[i] -= 1
                tmp.append(i)
                self.Back(res,tmp,ss,counter)
                counter[i] += 1
                tmp.pop()</code></pre><h3 id="fb7c9bf7-d032-400d-9e27-f893c4a5bab2" class="">【时间效率】28. 数组中出现次数超过一半的数字</h3><p id="b9ed1625-d246-4d8d-bc63-b999820bff46" class="">数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><p id="cc66ebb8-7942-43ad-9abc-48900f2c0e4e" class=""><strong>题解</strong></p><ul id="df093612-3545-46c0-ae39-df0a9e1d8e59" class="bulleted-list"><li>创dict记录次数<p id="269ca8fd-5a84-40d4-9cc3-2c8c685cdfde" class="">时间复杂度O(n)?</p></li></ul><ul id="3a882412-8ba7-48a4-b776-c9d36194721f" class="bulleted-list"><li>数组排序后，如果符合条件的数存在，则一定是数组中间那个数<p id="e20945bc-1365-4f7e-b1a2-07d960be8b86" class="">快排sort，时间复杂度O(NlogN)</p></li></ul><ul id="5c2bb31e-e54e-400a-a58e-cad455b84ac5" class="bulleted-list"><li>如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多<p id="bd334130-1afb-4548-a382-becd7b87fa82" class="">在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。</p></li></ul><pre id="97338603-61a2-4e78-bf31-91aedfe1d189" class="code"><code># dict/counter
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        n_dict = dict((x,0) for x in numbers)
        for i in numbers:
            n_dict[i]+=1
            if n_dict[i] &gt; len(numbers)//2:
                return i
        return 0
# 排序
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        # 对列表进行快排
        left = 0
        right = len(numbers) - 1
        stack = [right, left]
        while stack:
            low = stack.pop()
            high = stack.pop()
            if low &gt;= high:
                continue
            less = low - 1
            mid = numbers[high]
            for i in range(low, high):
                if numbers[i] &lt;= mid:
                    less += 1
                    numbers[less], numbers[i] = numbers[i], numbers[less]
            numbers[less + 1], numbers[high] = numbers[high], numbers[less + 1]
            stack.extend([high, less+2, less, low])
        # 验证
        count = 0
        length = len(numbers) // 2
        for i in numbers:
            if i == numbers[length // 2]:
                count += 1
        return numbers[length // 2] if count &gt; length / 2.0 else 0
# +1-1
class Solution:
    def MoreThanHalfNum_Solution(self, numbers):
        if not numbers:
            return 0
        num = numbers[0]
        count = 1
        for i in range(1, len(numbers)):
            if numbers[i] == num:
                count += 1
            else:
                count -= 1
            if count == 0:
                num = numbers[i]
                count = 1
        count = 0
        for i in numbers:
            if i == num:
                count += 1
        return num if count &gt; len(numbers) / 2.0 else 0
# Mia
class Solution:
	def MoreThanHalfNum_Solution(self, numbers):
        if len(numbers)==1:
            return numbers[0]
        elif numbers.count(sorted(numbers)[int(len(numbers)/2)+1]) &gt; len(numbers)/2:
            return sorted(numbers)[int(len(numbers)/2)+1]
        else:
            return 0</code></pre><h3 id="192f3eb8-45a1-4b5d-86bd-cace8abae9a2" class="">【时间效率】29. 最小的K个数</h3><p id="22196c5d-b2ec-4a64-b67a-06f81d3a410a" class="">输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4</p><p id="b52e8a8e-7843-4941-8e14-853eed59975b" class=""><strong>题解</strong></p><ul id="ce980e85-dbb7-4b78-89df-7e96f97bdcf8" class="bulleted-list"><li>快排 时间复杂度O(nlogn)</li></ul><ul id="1cad7cd7-b518-4658-a429-d255703b2e3f" class="bulleted-list"><li>partition 时间复杂度O(n)<p id="60b09614-44c4-4202-8e83-d7fe511f550e" class="">使比第k个元素小的元素放左边，比其大的元素放右边</p></li></ul><ul id="9ec5a586-a1d7-4874-b1e4-aaa1ad089190" class="bulleted-list"><li>最小堆<p id="0692d287-0ce2-4999-98af-c7893c7b0a6e" class="">用最小堆保存这k个数，每次只和堆顶比，如果比堆顶小，删除堆顶，新数入堆</p></li></ul><figure id="ed31b5de-b112-482e-987c-4709e3da3a3e" class="image"><a href="Offer/Untitled%2010.png"><img style="width:672px" src="Offer/Untitled%2010.png"/></a></figure><pre id="e7a4a9b9-e723-4113-9a47-14f613ed822c" class="code"><code># 作弊方法-排序
class Solution:
    def GetLeastNumbers_Solution(self, tinput, k):
      <mark class="highlight-red_background">  if k &lt;= len(tinput): #注意条件 </mark>
            return sorted(tinput)[:k]
        else:
            return []
# partition
import random
class Solution:
    def GetLeastNumbers_Solution(self, tinput, k):
        # write code here
        n = len(tinput)
        if n&lt;=0 or k&gt;n:
            return []
        if k==0:
            return []
        start = 0
        end = n-1
        index = self.partition(tinput,start,end)
        while index != k-1:
            if index &gt;k-1:
                end = index - 1
                index = self.partition(tinput,start,end)
            else:
                start = index +1
                index = self.partition(tinput,start,end)
        res = tinput[:k]
        res=sorted(res)
        return res

    def partition(self,arr,start,end):
        if start==end:
            p=start
        else:
            p = random.randrange(start,end)
        arr[p],arr[end]=arr[end],arr[p]
        small = start-1
        for i in range(start,end):
            if arr[i]&lt;arr[end]:
                small+=1
                if small != i:
                    arr[small],arr[i]=arr[i],arr[small]
        small +=1
        arr[small],arr[end]=arr[end],arr[small]
        return small
# 最小堆
class Solution:
    def minFixHeap(self,t,i,n):
        tmp = t[i]
        j = i*2+1
        while j &lt; n:
            if j+1 &lt;n and t[j+1] &lt; t[j]:
                j+=1
            if t[j] &gt;= tmp:
                break
            t[i] = t[j]
            i = j
            j = i*2 +1
        t[i] = tmp
 
    def GetLeastNumbers_Solution(self, tinput, k):
        lens = len(tinput)
        if k&gt;lens or k &lt;0 or lens ==0:
            return []
 
        for i in range(lens/2,-1,-1):
            self.minFixHeap(tinput,i,lens)
 
        res = []
        for i in range(lens-1,lens-k-1,-1):
            res.append(tinput[0])
            tinput[0] = tinput[i]
            self.minFixHeap(tinput,0,i)
        return res</code></pre><h3 id="79ed05da-e62a-43df-b5bf-5132099a741f" class="">【时间效率】30. 连续子数组的最大和</h3><p id="6e67101d-0712-4215-bd6f-cd96a22bf143" class="">HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><p id="c800f493-3815-471e-885c-5108156967e4" class=""><strong>题解</strong></p><ul id="63a3ecee-a448-4e5e-96d0-5c3be4bf8986" class="bulleted-list"><li>一个loop O(n)</li></ul><ul id="de809a9f-6e16-415e-a50f-f713376f7beb" class="bulleted-list"><li><strong><mark class="highlight-red_background">动态规划</mark></strong><p id="7aa06b04-60d7-4456-b493-76079c7b8d64" class="">dp[i]表示以元素array[i]结尾的最大连续子数组和. </p><p id="aa378769-dc89-4252-831b-e13871894dd9" class="">以[-2,-3,4,-1,-2,1,5,-3]为例</p><p id="0e41e5a8-0a74-4433-88d3-ed7203eb5e40" class="">可以发现,</p><p id="40aa2164-40fe-4a98-a9c0-2353801ad0a7" class="">dp[0] = -2</p><p id="8355b86d-6bc6-4a96-b95e-40ac00239575" class="">dp[1] = -3</p><p id="4e9b3863-97a2-4707-a16a-1fca41b96e0b" class="">dp[2] = 4</p><p id="f8c38998-9bc2-4855-b0a1-9b9e85141ab4" class="">dp[3] = 3</p><p id="ed6cebf4-8798-457f-9ee6-770d84927464" class="">以此类推,会发现</p><p id="01745968-818e-4aa0-8c32-7c35a72ab1aa" class="">dp[i] = max{dp[i-1]+array[i],array[i]}.</p></li></ul><pre id="ced23459-f912-467f-a85e-8d9eac80ee46" class="code"><code># 一个loop
class Solution:
    def FindGreatestSumOfSubArray(self,array):
        res = -7e20
        tmp = 0
        for i in range(len(array)):
            tmp += array[i]
            if tmp &gt; res:
                res = tmp
            if tmp &lt; 0:
                tmp = 0
        return res
# 动态规划
class Solution:
    def FindGreatestSumOfSubArray(self, array):
        n = len(array)
        dp = [ i for i in array]
        for i in range(1,n):
            dp[i] = max(dp[i-1]+array[i],array[i])
         
        return max(dp)</code></pre><h3 id="29cb8fed-6970-4062-b83d-6e0d9a64ea5a" class="">【时间效率】31. 整数中1出现的次数（从1到n整数中1出现的次数）</h3><p id="639ade26-3221-4e7c-a076-2aa7cfd824f0" class="">求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><p id="c5e0e37f-62d3-4454-8d26-3e9917203349" class=""><strong>题解</strong></p><p id="d1f7462a-0159-4aec-8589-5810515b3cb9" class="">像类似这样的问题，我们可以通过归纳总结来获取相关的东西。</p><p id="28bb7e22-4cad-42ca-8404-a3f3d167da6b" class="">首先可以先分类：</p><ul id="0384d5db-48f7-4dd6-8208-8071e8f70065" class="toggle"><li><details open=""><summary>个位</summary><p id="3ea2f213-4cbe-4a66-83b6-1cfdf2b087af" class="">我们知道在个位数上，1会每隔10出现一次，例如1、11、21等等，我们发现以10为一个阶梯的话，每一个完整的阶梯里面都有一个1，例如数字22，按照10为间隔来分三个阶梯，在完整阶梯0-9，10-19之中都有一个1，但是19之后有一个不完整的阶梯，我们需要去判断这个阶梯中会不会出现1，易推断知，如果最后这个露出来的部分小于1，则不可能出现1（这个归纳换做其它数字也成立）。</p><p id="32a13222-31f4-4aef-8e99-b8b38c7a0369" class="">我们可以归纳个位上1出现的个数为：</p><blockquote id="2b4e3cbc-c66d-44a6-84d5-5aa843400b7c" class="">n/10 * 1+(n%10!=0 ? 1 : 0)</blockquote></details></li></ul><ul id="9b5ddf6e-7350-4482-9bb7-ac309d0f8928" class="toggle"><li><details open=""><summary>十位</summary><p id="fb8d4fa4-e5d2-4078-81ed-82c8aec2f099" class="">现在说十位数，十位数上出现1的情况应该是10-19，依然沿用分析个位数时候的阶梯理论，我们知道10-19这组数，每隔100出现一次，这次我们的阶梯是100，例如数字317，分析有阶梯0-99，100-199，200-299三段完整阶梯，每一段阶梯里面都会出现10次1（从10-19），最后分析露出来的那段不完整的阶梯。我们考虑如果露出来的数大于19，那么直接算10个1就行了，因为10-19肯定会出现；如果小于10，那么肯定不会出现十位数的1；如果在10-19之间的，我们计算结果应该是k - 10 + 1。例如我们分析300-317，17个数字，1出现的个数应该是17-10+1=8个。</p><p id="0842ab37-fa29-4d3f-b47f-25f6a858faf9" class="">那么现在可以归纳：十位上1出现的个数为：</p><blockquote id="cd6e4322-427c-490e-a2b6-88d9c4d56e84" class="">设k = n % 100，即为不完整阶梯段的数字 归纳式为：(n / 100) * 10 + (if(k &gt; 19) 10 else if(k &lt; 10) 0 else k - 10 + 1)</blockquote></details></li></ul><ul id="72d292d7-932d-4ec8-adc2-ee0d631cc8a3" class="toggle"><li><details open=""><summary>百位</summary><p id="3810b1ca-9767-490f-a429-e9c7f0a35ee3" class="">现在说百位1，我们知道在百位，100-199都会出现百位1，一共出现100次，阶梯间隔为1000，100-199这组数，每隔1000就会出现一次。这次假设我们的数为2139。跟上述思想一致，先算阶梯数 * 完整阶梯中1在百位出现的个数，即n/1000 * 100得到前两个阶梯中1的个数，那么再算漏出来的部分139，沿用上述思想，不完整阶梯数k199，得到100个百位1，100&lt;=k&lt;=199则得到k - 100 + 1个百位1。</p><p id="d4fdaaad-1942-4a95-928f-243b0bb0d614" class="">那么继续归纳百位上出现1的个数：</p><blockquote id="9de1c078-42f5-4cb1-b746-6ca52b0e321f" class="">设k = n % 1000 归纳式为：(n / 1000) * 100 + (if(k &gt;199) 100 else if(k &lt; 100) 0 else k - 100 + 1)</blockquote><p id="049b4e6e-9347-497d-8b0e-ef0b2758105f" class="">后面的依次类推....</p></details></li></ul><ul id="812cbed7-8f2d-4eeb-b179-8a6458a37fc9" class="toggle"><li><details open=""><summary>再次回顾个位</summary><p id="4ee16ae6-6b0b-4d97-9d22-13857501fc9b" class="">我们把个位数上算1的个数的式子也纳入归纳式中</p><blockquote id="f5a5bfa5-beea-49c2-9eb2-d16f9152f625" class="">k = n % 10 个位数上1的个数为：n / 10 * 1 + (if(k &gt; 1) 1 else if(k &lt; 1) 0 else k - 1 + 1)</blockquote></details></li></ul><p id="59c8df95-9d1d-4a5d-aaf6-a616b5ec8114" class="">完美！归纳式看起来已经很规整了。 来一个更抽象的归纳，设i为计算1所在的位数，i=1表示计算个位数的1的个数，10表示计算十位数的1的个数等等。</p><blockquote id="d7acae03-95d3-4981-bd73-be567cc520cc" class="">k = n % (i * 10) count(i) = (n / (i * 10)) * i + (if(k &gt; i * 2 - 1) i else if(k &lt; i) 0 else k - i + 1)</blockquote><p id="4de4704d-fc60-4575-b3d8-3a09f4b197bb" class="">好了，这样从10到10的n次方的归纳就完成了。</p><blockquote id="1a47b4b1-bb5d-4640-908c-0f3cd1340a8a" class="">sum1 = sum(count(i))，i = Math.pow(10, j), 0&lt;=j&lt;=log10(n)</blockquote><p id="2122f7f4-7596-403a-9a06-1138c98758b2" class="">但是有一个地方值得我们注意的，就是代码的简洁性来看，有多个ifelse不太好，能不能进一步简化呢？ 我们可以把后半段简化成这样，我们不去计算i * 2 - 1了，我们只需保证k - i + 1在[0, i]区间内就行了，最后后半段可以写成这样</p><blockquote id="f6532af7-b3c6-4da1-92f7-fd6a59143071" class="">min(max((n mod (i*10))−i+1,0),i)</blockquote><p id="abb573d6-5457-4e03-87a4-2fb524db8bb6" class="">对于<strong>824883294</strong>，先求0－800000000之间（不包括800000000）的，再求0－24883294之间的。
如果等于1，如1244444，先求0－1000000之间，再求1000000－1244444，那么只需要加上244444＋1，再求0－244444之间的1
如果大于1，例：0－800000000之间1的个数为8个100000000的1的个数加上100000000，因为从1000000000－200000000共有1000000000个数且最高位都为1。
对于最后一位数，如果大于1，直接加上1即可。</p><pre id="356fcf61-8bcf-4d2a-a791-a5f2a2c37bd9" class="code"><code>class Solution:
    def NumberOf1Between1AndN_Solution(self, n):
        result = 0
        if n &lt; 0:
            return 0
        length = len(str(n))
        listN = list(str(n))
        for i, v in enumerate(listN):
            a = length - i - 1  # a为10的幂
            if i==length-1 and int(v)&gt;=1:
                result+=1
                break
            if int(v) &gt; 1:
                result += int(10 ** a * a / 10) * int(v) + 10**a
            if int(v) == 1:
                result += (int(10 ** a * a / 10) + int(&quot;&quot;.join(listN[i+1:])) + 1)
        return result</code></pre><h3 id="ffaee261-2b2f-4130-b588-6990e6fa98ed" class="">【时间效率】32. 把数组排成最小的数</h3><p id="b9c65f44-bd4e-4fce-b348-005cac0f7957" class="">输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><p id="3cda028e-00ab-4ee2-b913-c763d88d065d" class=""><strong>题解</strong></p><div id="d9f03b2f-4847-473d-b2b2-49e9f0b71c0b" class="column-list"><div id="c1d4570e-c82e-4450-914c-99777d07e6b0" style="width:68.75%" class="column"><ol id="1afa2a89-adf8-4bb8-9ec0-466cc357f8be" class="numbered-list" start="1"><li>不够位数的补齐比较即可</li></ol><ol id="9c75b5d5-6c8f-4aac-ba6d-0fd97a7cde13" class="numbered-list" start="2"><li>注意string可以起到拼接+比较大小的作用</li></ol><p id="f206368c-8df0-407b-b4f1-8b144ed9c793" class="">
</p></div><div id="d77188f9-53ce-47ad-93dc-b95681cc891e" style="width:31.25%" class="column"><figure id="9daf9011-779e-4b62-a2d9-39d7e4c39a69" class="image"><a href="Offer/Untitled%2011.png"><img style="width:342px" src="Offer/Untitled%2011.png"/></a></figure></div></div><pre id="41745a57-8679-435d-b8f7-1a37c3ec8bcc" class="code"><code># 补齐位数
class Solution:
    def PrintMinNumber(self,numbers):
        if not numbers:
            return &#x27;&#x27;
        maxl = len(str(max(numbers)))
        tmp = [str(x) for x in numbers]
        for i in range(len(tmp)):
            while len(tmp[i]) &lt; maxl:
                tmp[i] += tmp[i][-1]
        tmp = [int(x) for x in tmp]
        zlist = list(zip(tmp,numbers))
        zlist = sorted(zlist, key = lambda x:x[0])
        res = &#x27;&#x27;
        for i in zlist:
            res += str(i[1])
        return res.lstrip(&#x27;0&#x27;) or 0
# 比较两个字符串加起来大小
# python3没有cmp
class Solution:
    def PrintMinNumber(self, numbers):
        # write code here
        if not numbers: return &quot;&quot;
        numbers = list(map(str, numbers))
        numbers.sort(cmp=lambda x, y: cmp(x + y, y + x))
        return &quot;&quot;.join(numbers).lstrip(&#x27;0&#x27;) or&#x27;0
#Mia --- 网上看冒泡思路后自己写的：先转成string，利用string不断拼接找到最小的数
def PrintMinNumber(self, numbers):
        # write code her
        if numbers is None or numbers == []:
            return &quot;&quot;
        if len(numbers)==1:
            return numbers[0]
        numbers = [str(i) for i in numbers]
        for i in range(len(numbers)):
            for j in range(i,len(numbers)):
                if numbers[j]+numbers[i]&lt;numbers[i]+numbers[j]:
                    numbers[i],numbers[j]=numbers[j],numbers[i]
        return int(&#x27;&#x27;.join(numbers))</code></pre><h3 id="d11ea4c0-9f80-4d4b-9019-5d801922107f" class="">【时间空间效率的平衡】33. 丑数</h3><p id="df81d400-ddec-4647-84f7-20b6e25ed4cc" class="">把<mark class="highlight-orange_background">只包含质因子2、3和5的数称作丑数</mark>（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><p id="766d6fdd-6eee-4a41-8d03-f4aac870440d" class=""><strong>题解</strong></p><ul id="70ecb58c-ece4-4d9f-a4d9-6a72e80c44bb" class="bulleted-list"><li>逐个判断每个整数是否为丑数，时间复杂度高</li></ul><ul id="9211e267-3dab-4c3a-b83e-95bf76880562" class="bulleted-list"><li>创建数组存储已找到丑数，用空间换时间<p id="a476ad81-d697-48d5-9761-b1eb155d6386" class="">说下思路，如果p是丑数，那么<mark class="highlight-red_background">p=2^x * 3^y * 5^z</mark></p><p id="3d4e7bdf-500b-4b0b-b2e7-e58605932da9" class="">那么只要赋予x,y,z不同的值就能得到不同的丑数。</p><p id="fefed81b-1655-4cab-a60e-1ab010a92272" class="">如果要顺序找出丑数，要知道下面几个特点：
对于任何丑数p：
（一）2*p,3*p,5*p都是丑数，并且2*p&lt;3*p&lt;5*p
（二）如果p&lt;q, 那么2*p&lt;2*q,3*p&lt;3*q,5*p&lt;5*q</p><p id="171fb22c-62a0-46d7-86db-4d344daf6f5d" class="">现在说说算法思想：
    由于1是最小的丑数，那么从1开始，把2*1，3*1，5*1，进行比较，得出最小的就是1
的下一个丑数，也就是2*1，
    这个时候，多了一个丑数‘2’，也就又多了3个可以比较的丑数，2*2，3*2，5*2，
这个时候就把之前‘1’生成的丑数和‘2’生成的丑数加进来也就是
(3*1,5*1,2*2，3*2，5*2)进行比较，找出最小的。。。。如此循环下去就会发现，
每次选进来一个丑数，该丑数又会生成3个新的丑数进行比较。</p><p id="0bc421f7-efa0-4a08-8cd5-9c7de831f5c9" class="">下面说一个O（n）的算法。
既然有p&lt;q, 那么2*p&lt;2*q，那么“我”在前面比你小的数都没被选上，你后面生成新的丑数一定比“我”大吧，那么你乘2生成的丑数一定比我乘2的大吧，那么在我选上之后你才有机会选上。
其实每次我们只用比较3个数：</p><p id="7d0b8ccc-0f98-4ed9-b157-16a1ecb19840" class="">用于乘2的最小的数、用于乘3的最小的数，用于乘5的最小的数。也就是比较(2*x , 3*y, 5*z) ，x&gt;=y&gt;=z的</p><p id="cb4e9bfd-0d1a-4f66-8755-d6982d9738ad" class=""><strong><mark class="highlight-blue">另一个解释：</mark></strong></p><p id="acafa71c-05e9-422d-a183-948048e94459" class="">找出最小值之后的替换 是指之前顺序排列的丑数数组的每个值（！）都要乘以2,3,5的比较，一开始1*2和1*3和1*5 比较，找出最小的是2，把2放进a数组，这时候替换2的数就是2*2,；比较2*2,1*3,1*5，找到最小的是3，把3放进a数组，替换3的是2*3；比较2*2,2*3,1*5，找到最小是4,4放进a数组，这时候替换的用来乘以2的数就是3即3*2</p></li></ul><pre id="4de470fb-6ed9-4dd7-971d-1a12bf5863d8" class="code"><code># 逐个判断
class Solution:
    def GetUglyNumber_Solution(self, index):
        n = 1
        c = 1
        while c &lt; index:
            if self.isUgly(n):
                n+=1
                c+=1
            else:
                n+=1
        return n
    def isUgly(self, number):
        while number%2 == 0:
            number/=2
        while number%2 == 0:
            number/=3
        while number%5 == 0:
            number/=5
        return True if number == 1 else False
<mark class="highlight-orange_background"><strong># 空间换时间</strong></mark>
def GetUglyNumber_Solution(self, index):
    if index &lt; 7: #不包含7，7是单纯质数
        return index
    res = [1] #初始化有1
    t2 = t3 = t5 = 0
    for i in range(1,index):
        res.append(min(res[t2]*2,min(res[t3]*3,res[t5]*5)))
        if res[i] == res[t2]*2 : t2+=1
        if res[i] == res[t3]*3 : t3+=1
        if res[i] == res[t5]*5 : t5+=1
    return res[-1]</code></pre><h3 id="e2cb0014-db35-4071-a11a-030c39873122" class="">【时间空间效率的平衡】34. 第一个只出现一次的字符位置</h3><p id="da0619a2-ce8b-4df6-a658-d1dc8a44ed5d" class="">在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）</p><p id="63253112-377b-49bf-8d99-6f85ec1b60c2" class=""><strong>题解</strong></p><ul id="1ff637b7-e381-432e-a913-880792d50765" class="bulleted-list"><li>一次循环初始化cDict，一次循环生成记录字符出现次数的dict，一次循环找到count为1的字符，一次循环找第一个字符</li></ul><pre id="73387246-7db9-4bdf-b3c3-af29ce1d53d7" class="code"><code># 时间复杂度O(n)
class Solution:
    def FirstNotRepeatingChar(self, s):
        cDict = dict((x,0) for x in set(s))
        for i in s:
            cDict[i] += 1
        sList = []
        for sString,sCount in cDict.items():
            if sCount == 1:
                sList.append(sString)
        for i in range(len(s)):
            if s[i] in sList:
                return i
        return -1
# 一行写法（用count method）
def FirstNotRepeatingChar(s):
    return [i for i in range(len(s)) if s.count(s[i])==1][0] if s else -1</code></pre><h3 id="95ad73d2-a1df-4da3-8a16-daf07b16d561" class="">35. 数组中的逆序对</h3><p id="2e85ef76-55e0-4e10-8407-9a0e6799bf02" class="">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><p id="b1752d46-994b-45cf-b395-f9856935b914" class=""><strong>输入描述:</strong></p><p id="e8008d97-b1f8-4f67-85ec-ac5d0d85c964" class="">题目保证输入的数组中没有的相同的数字</p><p id="26dff79b-cc97-4a3e-860e-d4fdd5e964bf" class="">数据范围：<div class="indented"><p id="d620d10f-0be9-46d5-b01d-68348d5f7d3f" class="">对于%50的数据,size&lt;=10^4</p><p id="761d4f31-3861-484d-be08-ae2f0f97cd15" class="">对于%75的数据,size&lt;=10^5</p><p id="5fc6f0e8-19a3-4465-9993-f0deae8361e5" class="">对于%100的数据,size&lt;=2*10^5</p></div></p><p id="93c548c3-b702-444a-a640-c53fb5c3a343" class="">示例1<div class="indented"><p id="faba0b79-d682-4730-8ae2-8cd65958d573" class="">输入：1,2,3,4,5,6,7,0</p><p id="991de27a-4858-4303-92a7-c16b4f04f8d5" class="">输出：7</p></div></p><p id="3a047cc0-4b02-471b-b0a5-710c4eea881f" class=""><strong>题解</strong></p><ul id="3f0a9287-3c60-4e96-95a8-19cefe0e966f" class="bulleted-list"><li>暴力求解法，时间复杂度为o（n^2）,空间复杂度o(1)</li></ul><ul id="9874a93a-68bb-480e-8e8d-46c5e91f02f0" class="bulleted-list"><li>归并排序的改进，把数据分成前后两个数组(递归分到每个数组仅有一个数据项)，合并数组，合并时，出现前面的数组值array[i]大于后面数组值array[j]时；则前面数组array[i]~array[mid]都是大于array[j]的，count += mid+1 - i<p id="46de8ab8-034e-47aa-bda4-a80cbd5d1610" class="">时间复杂度o(nlog(n)),空间复杂度0（n）</p></li></ul><p id="15e0bead-9dcf-4525-a04e-911e534743cd" class="">看到这个题目，我们的第一反应是顺序扫描整个数组。每扫描到一个数组的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有n个数字。由于每个数字都要和O(n)这个数字比较，因此这个算法的时间复杂度为O(n^2)。</p><p id="486f98ab-9253-4094-9171-91bb1c74207a" class="">我们以数组{7,5,6,4}为例来分析统计逆序对的过程。每次扫描到一个数字的时候，我们不拿ta和后面的每一个数字作比较，否则时间复杂度就是O(n^2)，因此我们可以考虑先比较两个相邻的数字。</p><figure id="8c9455e1-14b3-437c-bd5f-350a667b591c" class="image"><a href="https://uploadfiles.nowcoder.com/files/20180504/7491640_1525400721676_20170710223428592"><img style="width:432px" src="https://uploadfiles.nowcoder.com/files/20180504/7491640_1525400721676_20170710223428592"/></a></figure><p id="e6890287-9766-4bf7-9d70-dd946a77ff4d" class="">(a) 把长度为4的数组分解成两个长度为2的子数组；</p><p id="cc1d8227-0b77-4006-82e0-fcb626980feb" class="">(b) 把长度为2的数组分解成两个成都为1的子数组；</p><p id="77a5c5e7-fa3e-4dce-8d2f-07e41ef89690" class="">(c) 把长度为1的子数组 <strong>合并、排序并统计逆序对</strong> ；</p><p id="cb517a8a-ae28-4b9a-a284-fda2a5e2d483" class="">(d) 把长度为2的子数组合并、排序，并统计逆序对；</p><p id="bcfe2f05-e328-4b5c-ae87-36b559daeaf3" class="">在上图（a）和（b）中，我们先把数组分解成两个长度为2的子数组，再把这两个子数组分别拆成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 <strong>排序</strong> 如上图（c）所示， <strong>以免在以后的统计过程中再重复统计。</strong> </p><p id="8eea0ef7-7d1a-40d6-a22b-dfcf81576838" class=""><strong> </strong> 接下来我们统计两个长度为2的子数组子数组之间的逆序对。合并子数组并统计逆序对的过程如下图如下图所示。</p><p id="206cd732-3043-4035-99ed-5abd7dff2795" class="">我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数，如下图（a）和（c）所示。如果第一个数组的数字小于或等于第二个数组中的数字，则不构成逆序对，如图b所示。每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保 <strong>辅助数组（记为copy）</strong> 中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。</p><figure id="a00e7bab-bb7b-4dc1-b6bb-e94f0cd3dc6c" class="image"><a href="https://uploadfiles.nowcoder.com/files/20170711/7491640_1499735690500_20170711085550783"><img style="width:480px" src="https://uploadfiles.nowcoder.com/files/20170711/7491640_1499735690500_20170711085550783"/></a></figure><p id="c15771d6-0647-43e1-b1b6-15521ff86050" class="">过程：先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。</p><pre id="ca28e684-971b-43ea-ab38-22cd18c3e2c5" class="code"><code>count = 0
class Solution:
    def InversePairs(self, data):
        global count
        def MergeSort(lists):
            global count
            if len(lists) &lt;= 1:
                return lists
            num = int( len(lists)/2 )
            left = MergeSort(lists[:num])
            right = MergeSort(lists[num:])
            r, l=0, 0
            result=[]
            while l&lt;len(left) and r&lt;len(right):
                if left[l] &lt; right[r]:
                    result.append(left[l])
                    l += 1
                else:
                    result.append(right[r])
                    r += 1
                    count += len(left)-l
            result += right[r:]
            result += left[l:]
            return result
        MergeSort(data)
        return count%1000000007</code></pre><h3 id="5b151752-ad25-465b-b76f-21fa09678781" class="">36. 两个链表的第一个公共结点</h3><p id="ae8d113b-5f16-427c-834f-0366cdfdab00" class="">输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><p id="f19a8729-a9fe-4aba-b609-90d78afef063" class=""><strong>题解</strong></p><ul id="498ca7f0-ac22-4fd7-8a5d-986c3d55f590" class="bulleted-list"><li>暴力法，时间复杂度O(mn)</li></ul><ul id="694acc71-2748-490a-b899-49446a1c4a74" class="bulleted-list"><li>辅助栈，时间复杂度O(m+n)，空间复杂度O(m+n)<figure id="e49cb22c-abc4-4c6c-a311-33f254bf8ccb" class="image"><a href="Offer/Untitled%2012.png"><img style="width:624px" src="Offer/Untitled%2012.png"/></a></figure></li></ul><ul id="4e7d12f3-39e0-4dd5-81f9-e80c00397f4c" class="bulleted-list"><li>两链表连接，时间复杂度O(m+n)<p id="d3e5e17b-b79c-44c8-95c4-e1626d6c7abf" class="">0-1-2-3-4-5-null
a-b-4-5-null
如果有公共结点，那么指针一起走到末尾的部分，也就一定会重叠。看看下面指针的路径吧。
p1： 0-1-2-3-4-5-null(此时遇到ifelse)-a-b-<mark class="highlight-red"><strong>4</strong></mark>-5-null
p2:  a-b-4-5-null(此时遇到ifelse)0-1-2-3-<strong><mark class="highlight-red">4</mark></strong>-5-null
因此，两个指针所要遍历的链表就长度一样了！</p></li></ul><pre id="8837b627-655f-455b-bfa4-ed0e02e9783f" class="code"><code># 暴力法
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        while pHead1:
            tmp = pHead2
            while tmp:
                if pHead1 == tmp:
                    return pHead1
                tmp = tmp.next
            pHead1 = pHead1.next
        return None
# 辅助栈
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        if not pHead1 or not pHead2:
            return None
        stack1 = []
        stack2 = []
        while pHead1:
            stack1.append(pHead1)
            pHead1 = pHead1.next
        while pHead2:
            stack2.append(pHead2)
            pHead2 = pHead2.next
        res = None
        while stack1 and stack2:
            if stack1[-1] == stack2.pop():
                res = stack1.pop()
            else:
                break
        return res
# 两链表连接
class Solution:
    def FindFirstCommonNode(self, pHead1, pHead2):
        p1,p2=pHead1,pHead2
        while p1!=p2:
            p1 = p1.next if p1 else pHead2
            p2 = p2.next if p2 else pHead1
        return p1</code></pre><h3 id="4c186a3f-ddef-4c34-bd47-db2fe81e572b" class="">37. 数字在排序数组中出现的次数</h3><p id="781ff61c-54dc-4566-85a5-315fa26ecfac" class="">统计一个数字在排序数组中出现的次数。</p><p id="b7db19b3-b3ba-4e13-a58b-08ea2a6f0ec4" class=""><strong>题解</strong></p><ul id="95084cb6-4e2c-47a4-a8e8-2a0a37527918" class="bulleted-list"><li>二分法+找周边相同值，时间复杂度o(n)</li></ul><ul id="fc1fb1b8-fe1a-4141-a238-faa1c42ff68c" class="bulleted-list"><li>二分法找第一个k和最后一个k（递归）</li></ul><ul id="01022331-2c6a-46b4-ab57-251f707270f4" class="bulleted-list"><li>如果数字都为整数，二分法找k-0.5和k+0.5的位置相减即可</li></ul><ul id="f482fecc-5714-41c4-a7bf-70ff70a1c685" class="bulleted-list"><li>return data.count(k)</li></ul><pre id="0d08c871-537c-4f58-b642-74c2596f1579" class="code"><code># 二分法+找周边相同值，考虑升序和降序情况
class Solution:
    def GetNumberOfK(self, data, k):
        if not data or len(data) == 0:
            return 0
        if data[0] &gt; data[-1]:
            flag = True
        elif data[0] &lt; data[-1]:
            flag = False
        else:
            if data[0] == k:
                return len(data)
            else:
                return 0
        l = 0
        r = len(data)-1
        exist = False
        while l &lt;= r:
            mid = l + (r-l)//2
            if data[mid] == k:
                exist = True
                break
            elif data[mid] &gt; k:
                if flag:
                    l = mid+1
                else:
                    r = mid-1
            else:
                if flag:
                    r = mid-1
                else:
                    l = mid+1
        if exist:
            res = -1
            for i in range(mid,-1,-1):
                if data[i] == k:
                    res += 1
                else:
                    break
            for i in range(mid,len(data)):
                if data[i] == k:
                    res += 1
                else:
                    break
            return res
        else:
            return 0
# 二分法找第一个k和最后一个k（递归）,只能升序
class Solution:
		def GetFirstK(self, data, k):
		    low = 0
		    high = len(data) - 1
		    while low &lt;= high:
		        mid = (low + high) // 2
		        if data[mid] &lt; k:
		            low = mid + 1
		        elif data[mid] &gt; k:
		            high = mid - 1
		        else:
								#当到list[0]或不为k的时候跳出函数
		            if mid == low or data[mid - 1] != k:
		                return mid
		            else:
		                high = mid - 1
		    return -1
		 
		def GetLastK(self, data, k):
		    low = 0
		    high = len(data) - 1
		    while low &lt;= high:
		        mid = (low + high) // 2
		        if data[mid] &gt; k:
		            high = mid - 1
		        elif data[mid] &lt; k:
		            low = mid + 1
		        else:
		            if mid == high or data[mid + 1] != k:
		                return mid
		            else:
		                low = mid + 1
		    return -1
		 
		def GetNumberOfK(self, data, k):
		    if not data:
		        return 0
		    if self.GetLastK(data, k) == -1 and self.GetFirstK(data, k) == -1:
		        return 0
		    return self.GetLastK(data, k) - self.GetFirstK(data, k) + 1</code></pre><h3 id="1f7c65f3-0818-4623-a85f-070fc42548be" class="">38. 二叉树的深度</h3><p id="ac89512a-a0d6-43b4-b3c6-0c6da5e72548" class="">输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><p id="372cc0a8-6f83-4aa3-baa3-45ad36140035" class=""><strong>题解</strong></p><ul id="2c51ed8e-33bf-4fca-92e4-c3df2441d8fa" class="bulleted-list"><li>递归（层次遍历）</li></ul><ul id="4301d2e7-4c50-48db-bb74-6af98624747b" class="bulleted-list"><li>层次遍历也可以用队列完成</li></ul><pre id="c9e54c19-da09-401a-bd39-f27c847db285" class="code"><code># 递归
class Solution:
    def TreeDepth(self, pRoot):
        if not pRoot:
            return 0
        depth = self.dtree(pRoot,0)
        return depth
    def dtree(self, root, depth):
        if not root:
            return depth
        depth += 1
        return max(self.dtree(root.left,depth),self.dtree(root.right,depth))
# 递归改进版
class Solution:
    def TreeDepth(self, pRoot):
        if pRoot is None:
            return 0
        count = max(self.TreeDepth(pRoot.left), self.TreeDepth(pRoot.right)) + 1
        return count</code></pre><h3 id="0e2c2988-4683-4ede-ac4f-5c1458f1b99b" class="">39. 平衡二叉树</h3><p id="f1ca44c9-a336-46e8-95bb-58bdff4821dd" class="">输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p id="6e33eb7f-5cb7-41b1-ab92-ceea9c52df0e" class=""><strong>题解</strong></p><ul id="b6abb74e-172a-48a4-a1d9-fe535eebb75c" class="bulleted-list"><li>左右子树判断深度差是否不超过1</li></ul><ul id="c02bdb14-5e1a-4ec1-8ca6-13ffb39ef2e7" class="bulleted-list"><li>后续遍历，一边遍历一边判断是否平衡</li></ul><pre id="c9840368-ca01-41d2-8e69-11aec6be931d" class="code"><code># 左右子树判断深度差是否不超过1
class Solution:
    def IsBalanced_Solution(self, pRoot):
        if not pRoot:
            return True
        ldepth = self.dtree(pRoot.left,0)
        rdepth = self.dtree(pRoot.right,0)
        diff = abs(ldepth-rdepth)
        if diff &gt; 1:
            return False
        return self.IsBalanced_Solution(pRoot.left) &amp; self.IsBalanced_Solution(pRoot.right)
    def dtree(self, root, depth):
        if not root:
            return depth
        depth += 1
        return max(self.dtree(root.left,depth),self.dtree(root.right,depth))
# 每个结点只遍历一次
class Solution:
    res = True
    def IsBalanced_Solution(self, pRoot):
        # write code here
        self.helper(pRoot)
        return self.res 
    def helper(self,root):
        if not root:
            return 0
        if not self.res : return 1
        left = 1 + self.helper(root.left)
        right = 1 + self.helper(root.right)
        if abs(left-right)&gt;1:
            self.res = False
        return max(left,right)
# 另一种写法
class Solution:
    def IsBalanced_Solution(self, p):
        return self.dfs(p) != -1
    def dfs(self, p):
        if p is None:
            return 0
        left = self.dfs(p.left)
        if left == -1:
            return -1
        right = self.dfs(p.right)
        if right == -1:
            return -1
        if abs(left - right) &gt; 1:
            return -1
        return max(left, right) + 1</code></pre><h3 id="be8baaa2-286b-4c0a-a30f-f7ac1363415c" class="">40. 数组中只出现一次的数字</h3><p id="4dc27863-2a78-43c9-9c36-67e2d066f782" class="">一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p><p id="2e1acc3f-0b9d-45c6-ae27-71dd9780fd36" class=""><strong>题解</strong></p><ul id="42a50c1c-4afd-4f96-b501-e3e1b5638260" class="bulleted-list"><li>Dictionary</li></ul><ul id="e3cf1ad0-4c2b-4a36-b4fa-70dc85e874e8" class="bulleted-list"><li>异或运算（只有一个数字的话更简单）<p id="7546f0bd-60a8-45fc-bcb8-a5d8cad3a4d8" class="">位运算中异或的性质：两个相同数字异或=0，一个数和0异或还是它本身</p><figure id="c072b484-5029-49de-a51b-cc6a54c28087" class="image"><a href="Offer/Untitled%2013.png"><img style="width:576px" src="Offer/Untitled%2013.png"/></a></figure></li></ul><pre id="88d23f1b-6be1-46bd-ab0a-c0f224529117" class="code"><code># 自己写的O(n)解法
class Solution:
    # 返回[a,b] 其中ab是出现一次的两个数字
    def FindNumsAppearOnce(self, array):
        if not array or len(array) &lt; 2:
            return []
        cDict = dict((x,0) for x in array)
        for i in array:
            cDict[i] += 1
        res = []
        for val,cnt in cDict.items():
            if cnt == 1:
                res.append(val)
        return res
# 异或
class Solution:
    def FindNumsAppearOnce(self, array):
        if not array or len(array) &lt; 2:
            return []
        a = 0
        for i in array:
            a^=i
        idx = 0
        while a&amp;1 == 0:
            a = a&gt;&gt;1
            idx += 1
        r1,r2 = 0,0
        for i in array:
            if self.isBit(i,idx) == 0:
                r1^=i
            else:
                r2^=i
        return [r1,r2]
    def isBit(self, num, idx):
        num = num&gt;&gt;idx
        return num&amp;1</code></pre><h3 id="e9128db1-0e54-4bdd-82fd-d38eb30363d6" class="">41. 和为S的连续正数序列</h3><p id="feaa3302-e9e1-4d31-bcff-126606e14a49" class="">小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><p id="6b898bee-05dd-462a-8d8f-53d218a1161b" class="">输出描述:</p><blockquote id="ec20da12-8e8a-4937-b4c0-bd8924504107" class="block-color-gray_background">输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</blockquote><p id="2baf4b35-021b-4d7c-ad0c-3569fa8573bc" class=""><strong>题解</strong></p><ul id="feb0f27b-bb61-46c0-b1d3-a5b0c29ef1ce" class="bulleted-list"><li>从1到S一个个数字试，时间复杂度O(n^2)</li></ul><ul id="8d0ac63d-30e1-4c0f-a1ac-feb1c4461be8" class="bulleted-list"><li>两个指针在数组上滑动<figure id="fd8e30a4-ddd1-484a-a58d-0bc8ffd949e4" class="image"><a href="Offer/Untitled%2014.png"><img style="width:576px" src="Offer/Untitled%2014.png"/></a></figure></li></ul><pre id="65f2ab02-dfa7-4fa6-a0c1-9a56dabe8527" class="code"><code># 从1到S一个个数字试
class Solution:
    def FindContinuousSequence(self, tsum):
        tlist = list(range(1,tsum))
        res = []
        for i in range(tsum-1):
            a = []
            b = 0
            for j in range(i,tsum-1):
                a.append(j+1)
                b += (j+1)
                if b == tsum:
                    res.append(a)
                    break
                elif b &gt; tsum:
                    break
        return res
# 两个指针在数组上滑动
class Solution:
    def FindContinuousSequence(self, tsum):
        if tsum &lt; 3:
            return []
        res = []
        small,big = 1,2
        mid = (1 + tsum) / 2
        curSum = small + big
        
        while small &lt; mid:
            if curSum == tsum:
                res.append(range(small, big + 1))
                small += 2
                big += 1
                curSum -= small * 2 - 3
                curSum += big
            elif curSum &lt; tsum:
                big += 1
                curSum += big
            else:
                curSum -= small
                small += 1
        return res</code></pre><h3 id="8ea15a24-207e-48ac-9467-9301dca27dce" class="">42. 和为S的两个数字</h3><p id="69c23b45-7a1b-4251-ba7f-621f31057ceb" class="">输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p id="0e85649b-cf7a-470b-bf8e-0c080160b6a6" class="">输出两个数，小的先输出。</p><p id="c84bb645-135d-44d9-9ff2-a19f4787d25b" class=""><strong>题解</strong></p><p id="6487d610-8ca3-4b7e-b4e2-04edde8e8a5f" class="">前后两个指针</p><pre id="538e7508-8d33-4d30-84b1-32e6a5acd8b1" class="code"><code>class Solution:
    def FindNumbersWithSum(self, array, tsum):
        if not array or len(array)&lt;2:
            return []
        a,b = 0,len(array)-1
        while a &lt; b:
            if array[a]+array[b] == tsum:
                return [array[a],array[b]]
            elif array[a]+array[b] &gt; tsum:
                b-=1
            else:
                a+=1
        return []</code></pre><h3 id="5549db68-291e-4307-8c6f-91097cc67dd6" class="">43. 左旋转字符串</h3><p id="8f394e68-0192-4413-abe9-7e5770bbd9ba" class="">汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><p id="fa200065-56da-45d4-a921-edd12da913fc" class=""><strong>题解</strong></p><ul id="bf50fc58-2144-4e92-8f93-1b9486cca2e8" class="bulleted-list"><li>作弊法（slicing）</li></ul><ul id="0462dd4a-b4e3-4af6-8844-8cd634433ff7" class="bulleted-list"><li>设X=abc，Y=def，所以字符串可以表示成XY，如题干，问如何求得YX。假设X的翻转为XT，XT=cba，同理YT=fed，那么YX=(XTYT)T，三次翻转后可得结果<figure id="fa34002c-9928-4b77-9989-919630eda65b" class="equation"><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css')</style><div class="equation-container"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Y</mi><mi>X</mi><mo>=</mo><mo>(</mo><msup><mi>X</mi><mi>T</mi></msup><msup><mi>Y</mi><mi>T</mi></msup><msup><mo>)</mo><mi>T</mi></msup></mrow><annotation encoding="application/x-tex">YX=(X^TY^T)^T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span></span></span></span></span></div></figure></li></ul><pre id="57d7b0f2-cf02-4fb1-90b7-c7d7de3317ea" class="code"><code># 作弊
class Solution:
    def LeftRotateString(self, s, n):
        if not s or len(s) &lt; 1:
            return &quot;&quot;
        n = n%len(s)
        return s[n:]+s[:n]
# 反转
class Solution:
    def LeftRotateString(self, s, n):
        res, length = list(s), len(s)
        if n &gt; length : return &quot;&quot;
        for i in range(int(n/2)):
            res[i], res[n-1-i] = res[n-1-i], res[i]
        for i in range(n, int((n+length)/2)):
            res[i], res[length-1-i+n] = res[length-1-i+n], res[i]
        for i in range(int(length/2)):
            res[i], res[length-1-i] = res[length-1-i], res[i]
        return &quot;&quot;.join(res)</code></pre><h3 id="cf83731c-44d7-42d8-82df-9f877d6dbb9a" class="">44. 翻转单词顺序列</h3><p id="720b4160-ffce-4d51-9632-d599d55095b9" class="">牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><p id="ee714000-2548-4ebc-9fb7-e9354c2a4c6b" class=""><strong>题解</strong></p><ul id="0b58e175-8bab-4acd-bc17-38260c3a9251" class="bulleted-list"><li>作弊</li></ul><ul id="ea65ad24-7ed9-4fc0-afc8-c631806f58c5" class="bulleted-list"><li>两次翻转，第一次整体翻转，第二次每个单词再翻转 （时间O(n),空间O(1)）</li></ul><pre id="a6ab3008-16e1-4577-8f17-2785df2d2a10" class="code"><code># 作弊
class Solution:
    def ReverseSentence(self, s):
        s = s.split(&#x27; &#x27;)
        return &#x27; &#x27;.join(s[::-1])
# 作弊2
class Solution:
    def ReverseSentence(self, s):
        s = s.split(&#x27; &#x27;)
        a,b = 0,len(s)-1
        while a &lt; b:
            s[a],s[b] = s[b],s[a]
            a+=1
            b-=1
        return &#x27; &#x27;.join(s)
# 堆，无聊，复制了一个来
def ReverseSentence(self, s):
        alist = s.split(&quot; &quot;)
        stacklist = []
        for i in alist:
            stacklist.append(i)
        result = []
        while len(stacklist) &gt; 0:
            result.append(stacklist.pop())
        return &quot; &quot;.join([x for x in result])</code></pre><h3 id="0a03cc70-f092-468e-9934-7606a1703bd2" class="">45. 扑克牌顺子</h3><p id="3ce007d2-52b5-4d66-a6db-6ca69f891b7c" class="">LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)...他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子.....LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p><p id="ffb8ead6-fb9d-4923-9796-1ab11a46cf8f" class=""><strong>题解</strong></p><ul id="4bcc2952-8363-44b2-8881-6e1fecf83109" class="bulleted-list"><li>max-min&lt;5即可，不允许重复</li></ul><ul id="3622fc77-8229-4432-bfbe-7eb1ed6e0dae" class="bulleted-list"><li>先统计王的数量，再把牌排序，如果后面一个数比前面一个数大于1以上，那么中间的差值就必须用王来补了。看王的数量够不够，如果够就返回true，否则返回false</li></ul><pre id="1cb5a808-3243-4b64-9978-03f21ba9ef0a" class="code"><code># max-min&lt;5
class Solution:
    def IsContinuous(self, numbers):
        if not numbers:
            return False
        if numbers.count(0) &lt; 4:
            numbers = [x for x in numbers if x!= 0]
            if len(numbers) == len(set(numbers)):
                if max(numbers)-min(numbers) &lt;= 4:
                    return True
            return False
        elif numbers.count(0) == 4:
            return True
# 用王补差
def IsContinuous(self, numbers):
    if not numbers:return False
    numbers.sort()
    zeroNum = numbers.count(0)
    for i, v in enumerate(numbers[:-1]):
        if v != 0:
            if numbers[i+1]==v:return False
            zeroNum = zeroNum - (numbers[i + 1] - v) + 1
            if zeroNum &lt; 0:
                return False
    return True</code></pre><h3 id="7a1c1f49-55e9-4dbe-979b-fcc813df1553" class="">46. 圆圈中最后剩下的数</h3><p id="9e2b4f2d-1950-4323-a1d8-05702b37b083" class="">0,1,...,n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。如果没有，请返回-1</p><p id="c2df2664-bc90-4d13-bf32-b8df78d20651" class=""><strong>题解</strong></p><ul id="b570d247-e277-4cb6-91e5-60714900210a" class="bulleted-list"><li>迭代剪掉第m个数字，把剩下的数组反过来拼起来，时间复杂度高O(mn)</li></ul><ul id="981aa0d5-eb65-4c5e-88af-08986fc3a9c1" class="bulleted-list"><li>使用list模拟循环链表，用cur作为指向list的下标位置，当到尾部时移到头部</li></ul><ul id="bd447be3-cc22-4091-8910-a27fb269f1b9" class="bulleted-list"><li>动态规划，时间复杂度O(n)<figure id="83a38e42-9f93-47b6-884d-838306781e48" class="image"><a href="Offer/Untitled%2015.png"><img style="width:576px" src="Offer/Untitled%2015.png"/></a></figure><figure id="efef9541-becc-4a10-9011-41dd9970669a" class="image"><a href="Offer/Untitled%2016.png"><img style="width:576px" src="Offer/Untitled%2016.png"/></a></figure></li></ul><pre id="c5e59de3-2280-41a7-b10b-c03fe0ed6c9d" class="code"><code># 迭代剪掉第m个数字
class Solution:
    def LastRemaining_Solution(self, n, m):
        if not n or n &lt;= 0:
            return -1
        tmp = [x for x in range(n)]
        while len(tmp) &gt; 1:
            a = m%len(tmp)
            if a == 0:
                tmp.pop()
            else:
                tmp = tmp[a:]+tmp[:a-1]
        return tmp[0]
# 动态规划
class Solution:
    def LastRemaining_Solution(self, n, m):
        if n &lt; 1 or m &lt; 1:
            return -1
        last = 0
        for i in range(2, n+1):
            last = (last+m)%i
        return last</code></pre><h3 id="927b2b29-f78e-4200-ac3f-c8262c093261" class="">【发散思维能力】47. 求1+2+3+...+n</h3><p id="c1e2c20b-f5d0-4ea5-85d7-c358d1c7a0c4" class="">求1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p id="b3ca378f-068a-414d-970d-d15b0f216dd1" class=""><strong>题解</strong></p><pre id="155539b0-be30-4d3b-9cd2-4bb5f424c15e" class="code"><code># 实际上是循环
return sum(range(n+1))
# 短路求值
## python中逻辑运算符的用法，a  and  b，a为False，返回a，a为True，就返回b
return n and n + self.Sum_Solution(n-1)</code></pre><h3 id="2d48b5c1-da6d-4ff5-bb11-96793302c5aa" class="">48. 不用加减乘除做加法</h3><p id="19958df0-0dc8-4661-bdbe-568d7021e77c" class="">写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><p id="066f6fda-9a6f-4c7a-b871-6eaed5cf39e9" class=""><strong>题解</strong></p><ul id="54fe97ed-7b20-412b-86ee-eb6d139898d3" class="bulleted-list"><li>二进制位运算<p id="6e4cb2af-e860-446a-bb81-7141506291b5" class=""><strong>解析一</strong></p><p id="17eca354-d3e3-4f96-b3fc-439bca0a914e" class="">首先补充知识，二进制算法是用补码计算的！补码！补码！重要的事情三遍！</p><p id="ff071dc5-073d-48cc-bb97-38817d8cf1c8" class="">首先正数举例，5+6：</p><p id="2aa8346f-0c66-4c08-9191-08b45625e35c" class="">bin(5)=0101,bin(6)=0110</p><p id="51fba5f5-e528-493c-8f42-6e12eb62182e" class="">首先我们在计算十进制的时候思路是这样的，5+6=11，首先看1，之后发现需要左移也就是所谓的进1，变成11，二进制是类似的;</p><p id="f672cb3f-af35-41b3-83fb-0f1ce56d28b7" class="">第一次，0101^0110=0011</p><p id="5f108b4c-c611-45b1-b9d8-f28092abea58" class="">0101&amp;0111=0100，发现0100！=0000，所以是需要进位左移 0100&lt;&lt;1=1000</p><p id="81fc00d4-3f4f-47c4-8133-4d76966567f4" class="">第二次, 0011^1000=1011</p><p id="c67fce98-a092-4c69-9598-f59a4d46d406" class="">0011&amp;1000=0000，发现0000==0000，所以返回1011，也就是11</p><p id="d6f939f9-354f-4448-b796-6e10705107fd" class="">之后负数举例，5-6：(以8位举例)</p><p id="6b7edb4f-88d1-4d61-bb11-f84a51b36526" class="">bin(5)=00000101,bin(-6)=10000110,反码:11111001,补码:11111010</p><p id="e749e67d-97d3-4637-8651-9ff5f6600090" class="">开始计算：</p><p id="3198a1c0-8829-4dd5-903f-2cf7fb27249f" class="">第一次，00000101^11111010=11111111</p><p id="1cd69881-ade1-4dc9-a7d2-d0f148f5cc88" class="">00000101&amp;11111010=00000000==00000000，注意11111111是补码，需要转换回去,反码11111110，源码10000001=-1，num1-pow(2,32)作用就是类似,255-256=-1</p><p id="fa7c5acd-c2ba-48b7-a50d-7bfc5fc7a416" class=""><strong>解析二</strong></p><p id="d114cdb0-c0ba-4a7c-9f38-300f515a7efe" class="">让我们实现两数相加，但是不能用加号或者其他什么数学运算符号，那么我们只能回归计算机运算的本质，位操作 Bit Manipulation，我们在做加法运算的时候，每位相加之后可能会有进位 Carry 产生，然后在下一位计算时需要加上进位一起运算，那么我们能不能将两部分拆开呢，我们来看一个例子 759+674</p><p id="c78d8c48-8356-4450-b5d4-af1a8840d6d1" class="">1. 如果我们不考虑进位，可以得到 323</p><p id="f2245ba8-41bc-4064-b796-9f8551d4a434" class="">2. 如果我们只考虑进位，可以得到 1110</p><p id="61a4949c-6f0d-49b3-8bd7-3b40940d1c2c" class="">3. 我们把上面两个数字假期 323+1110=1433 就是最终结果了</p><p id="d451772d-a146-4055-a22b-591c1711c083" class="">然后我们进一步分析，如果得到上面的第一第二种情况，我们在二进制下来看，不考虑进位的加，0+0=0，0+1=1, 1+0=1，1+1=0，这就是异或的运算规则，如果只考虑进位的加 0+0=0, 0+1=0, 1+0=0, 1+1=1，而这其实这就是&#x27;与&#x27;的运算，而第三步在将两者相加时，我们再递归调用这个算法，终止条件是当进位为0时，直接返回第一步的结果。一切都是如此的美好，突然有一天，博主的所有方法都无法通过 OJ 了，不知为何，原因不明。在热心网友 <a href="https://www.cnblogs.com/grandyang/p/5631814.html#4245765">GGGGITFK</a> 的提示下，终于知道了错误的原因：</p><p id="41552ef7-e918-4c1e-9916-e2e70ead6e82" class="">runtime error: left shift of negative value -2147483648，对INT_MIN左移位。</p><p id="6216ce46-8028-446c-ab37-6e575b6c14c4" class="">就是 LeetCode 自己的编译器比较 strict，不能对负数进行左移，就是说最高位符号位必须要为0，才能左移（此处应有尼克杨问号脸？！），好吧，你赢了。那么我们在a和b相&#x27;与&#x27;之后，再&#x27;与&#x27;上一个最高位为0，其余位都为1的数 0x7fffffff，这样可以强制将最高位清零，然后再进行左移。</p></li></ul><pre id="1094a3b6-ce94-4204-b2a2-af16a8d134e8" class="code"><code># 垃圾版，只能操作正整数
class Solution:
    def Add(self, num1, num2):
        num1,num2 = min(num1,num2),max(num1,num2)
        num1 = bin(num1)[2:][::-1]
        num2 = bin(num2)[2:][::-1]
        for _ in range(len(num2)-len(num1)):
            num1+=&#x27;0&#x27;
        res = []
        tmp = 0
        for i in range(len(num2)):
            if num1[i]==&#x27;0&#x27; and num2[i]==&#x27;0&#x27; and tmp==0:
                res.append(&#x27;0&#x27;)
            elif num1[i]==&#x27;0&#x27; and num2[i]==&#x27;0&#x27; and tmp==1:
                res.append(&#x27;1&#x27;)
                tmp = 0
            elif num1[i]==&#x27;1&#x27; and num2[i]==&#x27;1&#x27; and tmp==0:
                res.append(&#x27;0&#x27;)
                tmp = 1
            elif num1[i]==&#x27;1&#x27; and num2[i]==&#x27;1&#x27; and tmp==1:
                res.append(&#x27;1&#x27;)
            elif tmp==0:
                res.append(&#x27;1&#x27;)
            else:
                res.append(&#x27;0&#x27;)
        if tmp==1:
            res.append(&#x27;1&#x27;)
        res = int(&#x27;&#x27;.join(res[::-1]),2)
        return res
# 牛逼版
## 注意python没有无符号右移操作，所以需要越界检查
## 按位与运算：相同位的两个数字都为1，则为1；若有一个不为1，则为0。
## 按位异或运算：相同位不同则为1，相同则为0。
class Solution: 
    def Add(self, a, b):           
        while(b): 
           a,b = (a^b) &amp; 0xFFFFFFFF,((a&amp;b)&lt;&lt;1) &amp; 0xFFFFFFFF
        return a if a&lt;=0x7FFFFFFF else ~(a^0xFFFFFFFF)
# 位运算2
class Solution: 
    def Add(self, a, b):
				if b == 0:
						return a
				sum = a^b
				carry = (a &amp; b &amp; 0x7fffffff) &lt;&lt; 1
				return self.Add(sum, carry)</code></pre><h3 id="f1bd3f97-bde2-4965-9074-1688bf8cae7c" class="">49. 把字符串转换成整数</h3><p id="e811aed8-e390-4269-982a-bba2bcd178ef" class="">将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><p id="28b598b0-8187-44b1-8458-7cbd39142981" class=""><strong>输入描述:</strong></p><p id="5cad88e2-9e03-45c7-aede-7b3adc9b6c5e" class="">输入一个字符串,包括数字字母符号,可以为空</p><p id="e3ffc792-247a-4d9c-ba35-9981dbb5ffbb" class=""><strong>输出描述:</strong></p><p id="5d620eb9-096e-462f-b55e-eee49e293701" class="">如果是合法的数值表达则返回该数字，否则返回0</p><pre id="fb9921b6-af75-4e90-a0c9-8a5e4130ac0b" class="code"><code>输入
+2147483647
    1a33
输出
2147483647
    0</code></pre><p id="afdc91e0-aa55-4707-a897-40f552834722" class=""><strong>题解</strong></p><p id="77bf8e4f-c29a-49ba-a2b6-7c94ce5474fc" class="">需要考虑：</p><ul id="a467dc60-a2dc-4e77-a54b-a6eb4926e4a4" class="bulleted-list"><li>数据上下 溢出</li></ul><ul id="4520ffe2-55dd-436c-b230-017efca46782" class="bulleted-list"><li>空字符串</li></ul><ul id="7490196c-1387-4ed5-a42c-d43f6635ed65" class="bulleted-list"><li>只有正负号</li></ul><ul id="2dc5ecb7-9c27-4e35-9036-f8b827359dd1" class="bulleted-list"><li>有无正负号</li></ul><ul id="8b92fa22-dd72-4513-9ac9-2e21ae5c1836" class="bulleted-list"><li>错误标志输出</li></ul><pre id="8cf27ec1-7a8e-4f03-926f-e15330f6c0ca" class="code"><code>class Solution:
    def StrToInt(self, s):
        if s is None or len(s) == 0:
            return 0
        res = 0
        start = 0
        flag = True
        if s[0]==&#x27;+&#x27; or s[0]==&#x27;-&#x27;:
            start += 1
            if s[0]==&#x27;-&#x27;:
                flag = False
        for i in range(start,len(s)):
            if s[i]&gt;=&#x27;0&#x27; and s[i]&lt;=&#x27;9&#x27;:
                res = res*10 + (ord(s[i])-ord(&#x27;0&#x27;))
            else:
                return 0
        if flag:
            if res &gt; 0x7FFFFFFF:
                return 0
        else:
            if res &gt; 0x80000000:
                return 0
            res *= -1
        return res</code></pre><h3 id="eda69870-12be-477b-9842-517c2368a068" class="">50. 数组中重复的数字</h3><p id="b2c149fe-8679-44f5-a6f2-34cefd103d5f" class="">在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><p id="c0f274fd-ef88-4774-b0c2-7fdf362cdbd8" class=""><strong>题解</strong></p><ul id="1931fe69-866a-41f5-a206-bc7df7d56755" class="bulleted-list"><li>用了dict</li></ul><ul id="d1550802-a3aa-4b12-99f6-60626909e905" class="bulleted-list"><li>利用了哈希的特性，但不需要额外的存储空间。 因此时间复杂度为O(n)，不需要额外空间<ol id="643382d6-7d65-40c8-ab06-94a4821a9023" class="numbered-list" start="1"><li>把当前序列当成是一个下标和下标对应值是相同的数组</li></ol><ol id="f6acd762-6ffb-43ea-940a-2f74862f8c6f" class="numbered-list" start="2"><li>遍历数组，判断当前位的值和下标是否相等： 2.1. 若相等，则遍历下一位； 2.2. 若不等，则将当前位置i上的元素和a[i]位置上的元素比较：若它们相等，则成功！若不等，则将它们两交换。换完之后a[i]位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复2.2的操作，直到当前位置i的值也为i，将i向后移一位，再重复2.</li></ol></li></ul><pre id="c9e67646-782d-4e4f-abec-8bc7498438ee" class="code"><code># dict
class Solution:
    # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
    # 函数返回True/False
    def duplicate(self, numbers, duplication):
        cDict = {}
        for i in numbers:
            try:
                cDict[i]+=1
                duplication[0]=i
                return True
            except:
                cDict[i]=1
        return False
# 不用额外空间
class Solution:
    # 这里要特别注意~找到任意重复的一个值并赋值到duplication[0]
    # 函数返回True/False
    def duplicate(self, numbers, duplication):
        index = 0
        while index &lt; len(numbers):
            if numbers[index] == index:
                index += 1
            elif numbers[index] == numbers[numbers[index]]:
                duplication[0] = numbers[index]
                return True
            else:
                index_2 = numbers[index]
                numbers[index],numbers[index_2] = numbers[index_2],numbers[index]
        return False</code></pre><h3 id="006161f5-b49c-4ac7-9197-2cf152309346" class="">51. 构建乘积数组</h3><p id="336f6fd7-614f-4219-9931-8c0c05d0eb74" class="">给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>...*A[i-1]<em>A[i+1]</em>...*A[n-1]。不能使用除法。（注意：规定B[0] = A[1] * A[2] * ... * A[n-1]，B[n-1] = A[0] * A[1] * ... * A[n-2];）</p><p id="3ea63cdb-783e-40cb-ad46-792748317551" class=""><strong>题解</strong></p><ul id="232ce0a1-957a-43bb-aaba-c3ac377b2b42" class="bulleted-list"><li>笨拙O(n^2)</li></ul><ul id="2f328898-8ab3-4915-87c2-c3fc53c7cf9c" class="bulleted-list"><li>B[i]的值可以看作下图的矩阵中每行的乘积<p id="029a0a71-77a1-48b9-8417-232ba2c9f667" class="">下三角用连乘可以很容求得，上三角，从下向上也是连乘。</p><p id="5effbc75-a2d4-40c6-9997-e525639abb6d" class="">因此我们的思路就很清晰了，先算下三角中的连乘，即我们先算出B[i]中的一部分，然后倒过来按上三角中的分布规律，把另一部分也乘进去。</p><figure id="21d2da6e-d8e6-4d15-8a34-54bb0afda674" class="image"><a href="Offer/Untitled%2017.png"><img style="width:432px" src="Offer/Untitled%2017.png"/></a></figure></li></ul><pre id="2f0244df-4dbe-41f6-90e5-803765119b2a" class="code"><code># O(n^2)
class Solution:
    def multiply(self, A):
        B = []
        A.append(1)
        for i in range(len(A)-1):
            tmp = 1
            for j in A[:i]+A[i+1:]:
                tmp *= j
            B.append(tmp)
        return B
# 把每行被1分割的两部分乘积都计算出来，从首尾分别用累乘算出两个列表，两个列表首尾相乘就是B的元素
class Solution:
    def multiply(self, A):
        head = [1]
        tail = [1]
        for i in range(len(A)-1):
            head.append(A[i]*head[i])
            tail.append(A[-i-1]*tail[i])
        return [head[j]*tail[-j-1] for j in range(len(head))]</code></pre><h3 id="1e5a9a81-e44d-42d2-a3f6-96004fcf3981" class="">52. 正则表达式匹配</h3><p id="9dfbc3d1-4d93-43c1-98b1-4ec5d0e8819b" class="">请实现一个函数用来匹配包括&#x27;.&#x27;和&#x27;<em>&#x27;的正则表达式。模式中的字符&#x27;.&#x27;表示任意一个字符，而&#x27;</em>&#x27;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab<em>ac</em>a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配</p><p id="885305bc-c0d7-4062-a04a-b65a67f73483" class=""><strong>题解</strong></p><pre id="6a9596b4-0280-4f6e-88a7-071e810df4a8" class="code"><code>class Solution:
    # s, pattern都是字符串
    def match(self, s, pattern):
        # 如果s与pattern都为空，则True
        if len(s) == 0 and len(pattern) == 0:
            return True
        # 如果s不为空，而pattern为空，则False
        elif len(s) != 0 and len(pattern) == 0:
            return False
        # 如果s为空，而pattern不为空，则需要判断
        elif len(s) == 0 and len(pattern) != 0:
            # pattern中的第二个字符为*，则pattern后移两位继续比较
            if len(pattern) &gt; 1 and pattern[1] == &#x27;*&#x27;:
                return self.match(s, pattern[2:])
            else:
                return False
        # s与pattern都不为空的情况
        else:
            # pattern的第二个字符为*的情况
            if len(pattern) &gt; 1 and pattern[1] == &#x27;*&#x27;:
                # s与pattern的第一个元素不同，则s不变，pattern后移两位，相当于pattern前两位当成空
                if s[0] != pattern[0] and pattern[0] != &#x27;.&#x27;:
                    return self.match(s, pattern[2:])
                else:
                    # 如果s[0]与pattern[0]相同，且pattern[1]为*，这个时候有三种情况
                    # pattern后移2个，s不变；相当于把pattern前两位当成空，匹配后面的
                    # pattern后移2个，s后移1个；相当于pattern前两位与s[0]匹配
                    # pattern不变，s后移1个；相当于pattern前两位，与s中的多位进行匹配，因为*可以匹配多位
                    return self.match(s, pattern[2:]) or self.match(s[1:], pattern[2:]) or self.match(s[1:], pattern)
            # pattern第二个字符不为*的情况
            else:
                if s[0] == pattern[0] or pattern[0] == &#x27;.&#x27;:
                    return self.match(s[1:], pattern[1:])
                else:
                    return False</code></pre><h3 id="6cada625-974a-44c9-82f3-5d030e4217c0" class="">53. 表示数值的字符串</h3><p id="037da784-28b9-4c81-b9e9-7fe9eabd768f" class="">请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。</p><p id="366c7b1a-aa08-4ed1-a931-438523c59e82" class=""><strong>题解</strong></p><pre id="0d70aa2d-3322-4111-a4f0-e811304f44e5" class="code"><code>class Solution:
    # s字符串
    def isNumeric(self, s):
        if s is None or len(s) == 0:
            return False
        curr = 0
        e = 0
        d = 0
        if s[0] == &#x27;+&#x27; or s[0] == &#x27;-&#x27;:
            if len(s) == 1:
                return False
            curr = 1
        while curr &lt; len(s):
            if &#x27;0&#x27; &lt;= s[curr] and s[curr] &lt;= &#x27;9&#x27;:
                curr += 1
            elif s[curr] in [&#x27;e&#x27;,&#x27;E&#x27;]:
                e += 1
                if curr == len(s)-1 or e &gt; 1:
                    return False
                if s[curr+1] in [&#x27;-&#x27;,&#x27;+&#x27;]:
                    if curr == len(s)-2:
                        return False
                    curr += 1
                curr += 1
            elif s[curr] == &#x27;.&#x27;:
                d += 1
                if e == 1 or d &gt; 1 or curr == len(s)-1:
                    return False
                if s[curr+1] in [&#x27;+&#x27;,&#x27;-&#x27;,&#x27;E&#x27;,&#x27;e&#x27;]:
                    return False
                curr += 1
            else:
                return False
        return True</code></pre><h3 id="f789e4d8-71c5-4f8d-b2de-59ef524259ea" class="">54. 字符流中第一个不重复的字符</h3><p id="dd812079-073f-4651-93f6-3a92f2114a78" class="">请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。</p><p id="69505581-ed88-41ec-8db3-a2b53518a9fc" class="">输出描述:</p><p id="3f49014d-cbbf-45c3-b04e-baf02fdf95e7" class="">如果当前字符流没有存在出现一次的字符，返回#字符。</p><p id="ba5c64b1-5ea3-4549-b161-df0836ce895e" class=""><strong>题解</strong></p><ul id="99a8b3a6-6c39-448d-94bd-19c15bbf3cad" class="bulleted-list"><li>字典</li></ul><ul id="c1ba088b-c6d8-4cf6-930f-24f926d2bc85" class="bulleted-list"><li>利用一个int型数组表示256个字符（时间复杂度O（1），空间复杂度O（n））<ol id="dae5fea6-db0d-4477-8947-02b2949d6ae0" class="numbered-list" start="1"><li>利用一个int型数组表示256个字符，这个数组初值置为-1</li></ol><ol id="452feb9b-0c31-4e98-b8ea-5847e2279e9b" class="numbered-list" start="2"><li>每读出一个字符，将该字符的位置存入字符对应数组下标中</li></ol><ol id="1f9ad323-d56c-4ae7-bc4b-36161cfa9613" class="numbered-list" start="3"><li>若值为-1表示第一次读入，不为-1且&gt;0表示不是第一次读入，将值改为-2</li></ol><ol id="f9805e89-c7f8-437b-a888-7d6f03806359" class="numbered-list" start="4"><li>之后在数组中找到&gt;0的最小值，该数组下标对应的字符为所求。</li></ol><ol id="537da8a2-ea8b-41a8-b9f1-580d6c64fdba" class="numbered-list" start="5"><li>在python中，ord(char)是得到char对应的ASCII码；chr(idx)是得到ASCII位idx的字符</li></ol></li></ul><pre id="6ef4505c-82c9-4753-a5a2-9f079bb648d1" class="code"><code># 字典
class Solution:
    def __init__(self):
        self.s = &#x27;&#x27;
    def FirstAppearingOnce(self):
        if not self.s:
            return &#x27;#&#x27;
        cDict = dict((x,0) for x in self.s)
        for i in self.s:
            cDict[i] += 1
        for i in self.s:
            if cDict[i] == 1:
                return i
        return &#x27;#&#x27;
    def Insert(self, char):
        self.s += char
# int数组
class Solution:
    def __init__(self):
        self.char_list = [-1 for i in range(256)]
        self.index = 0  # 记录当前字符的个数，可以理解为输入的字符串中的下标
    def FirstAppearingOnce(self):
        min_value = 500
        min_idx = -1
        for i in range(256):
            if self.char_list[i] &gt; -1:
                if self.char_list[i] &lt; min_value:
                    min_value = self.char_list[i]
                    min_idx = i
        if min_idx &gt; -1:
            return chr(min_idx)
        else:
            return &#x27;#&#x27;
    def Insert(self, char):
        # 如果是第一出现，则将对应元素的值改为下边
        if self.char_list[ord(char)] == -1:
            self.char_list[ord(char)] = self.index
        # 如果已经出现过两次了，则不修改
        elif self.char_list[ord(char)] == -2:
            pass
        # 如果出现过一次，则进行修改，修改为-2
        else:
            self.char_list[ord(char)] = -2
        self.index += 1</code></pre><h3 id="79ea4ef2-c486-4d7d-832b-3dc0aa83f08d" class="">55. 链表中环的入口结点</h3><p id="d0577fc7-518e-4d0c-811c-50fd35993eed" class="">给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><p id="f7423a73-45c0-40ef-858c-dd01536fc95c" class=""><strong>题解</strong></p><ul id="a1124897-cd09-4fc2-9c8a-21a90c040bd8" class="bulleted-list"><li>list</li></ul><ul id="5a3323eb-7a6f-4b8b-a646-dcb5a144b01a" class="bulleted-list"><li>快慢指针   （时间复杂度：O(n)，空间复杂度：O(1)）<p id="f4e12db7-e736-4e63-a9a1-269ca2e53165" class=""><strong>1、设置快慢指针，假如有环，他们最后一定相遇。</strong></p><p id="3725b44d-605a-4aa5-883e-92a97fede2fd" class=""><strong>2、两个指针分别从链表头和相遇点继续出发，每次走一步，最后一定相遇于环入口。</strong></p><figure id="8d872081-8a00-4ae0-a19f-f888ecb4f3f1" class="image"><a href="Offer/Untitled%2018.png"><img style="width:432px" src="Offer/Untitled%2018.png"/></a></figure><p id="480249c6-930d-4362-a68d-3f97505b57e5" class="">假设x为环前面的路程（黑色路程），a为环入口到相遇点的路程（蓝色路程，假设顺时针走）， c为环的长度（蓝色+橙色路程）</p><p id="4d29b49c-c7f6-4a37-bc8b-4411667ad172" class="">当快慢指针相遇的时候：</p><p id="3fe540de-55ba-4b33-a02e-de3ec160dd24" class="">此时慢指针走的路程为Sslow = x + m * c + a </p><p id="81c1e844-dfdc-4445-9eca-483dea392572" class="">快指针走的路程为Sfast = x + n * c + a </p><p id="23b90cb8-c5b7-4f30-a68f-9cd18d31cc1a" class="">2 Sslow = Sfast </p><p id="e98e8bbe-b1d9-4d7b-b006-58ed29ac671a" class="">2 * ( x + m*c + a ) = (x + n *c + a) </p><p id="f85a417e-aeb4-4da6-b6ef-2c834b92702a" class="">从而可以推导出： x = (n - 2 * m )*c - a = (n - 2 *m -1 )*c + c - a </p><p id="8b2dd804-2111-423a-a107-3c1accb2ca18" class="">即环前面的路程 = 数个环的长度（为可能为0） + c - a </p><p id="65608008-a932-423a-989f-48047ab691d6" class="">什么是c - a？这是相遇点后，环后面部分的路程。（橙色路程） </p><p id="4bfb1071-ddd0-44d3-ad61-b0ef57710591" class="">所以，我们可以让一个指针从起点A开始走，让一个指针从相遇点B开始继续往后走， 2个指针速度一样，那么，当从原点的指针走到环入口点的时候（此时刚好走了x） 从相遇点开始走的那个指针也一定刚好到达环入口点。 所以2者会相遇，且恰好相遇在环的入口点。</p></li></ul><pre id="997aa112-4b83-41f5-b824-8b0df75afc1e" class="code"><code># list保存nodes
class Solution:
    def EntryNodeOfLoop(self, pHead):
        tempList = []
        p = pHead
        while p:
            if p in tempList:
                return p
            else:
                tempList.append(p)
            p = p.next
# 快慢指针
class Solution:
    def EntryNodeOfLoop(self, pHead):
        slow,fast=pHead,pHead
        while fast and fast.next:
            slow=slow.next
            fast=fast.next.next
            if slow==fast:
                slow2=pHead
                while slow!=slow2:
                    slow=slow.next
                    slow2=slow2.next
                return slow</code></pre><h3 id="dc035ed1-5e2f-4054-ba6e-4165c7aeb877" class="">56. 删除链表中重复的结点</h3><p id="78e4aa67-5e2c-4c21-b9d6-be0faf1792b2" class="">在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><p id="267119c7-dda1-41b0-a33d-a7dc85756f83" class=""><strong>题解</strong></p><ul id="9be92966-f56d-4d4b-9585-25dbff1fb210" class="bulleted-list"><li>两个指针，一个在后面记录不重复结点，另一个扫描链表</li></ul><ul id="9269107f-bfe1-49c8-8a06-4ecd11dfe34f" class="bulleted-list"><li>递归</li></ul><pre id="80afb33e-abc2-40f1-bd50-8505dd033468" class="code"><code># 双指针，pHead指向newHead开头，newHead扫描，遇到重复就用tmpNode向前判断重复终止
class Solution:
    def deleteDuplication(self, pHead):
        if pHead == None or pHead.next == None:
            return pHead
        newHead = ListNode(None)
        newHead.next = pHead
        pHead = newHead
        while newHead.next and newHead.next.next:
            if newHead.next.val == newHead.next.next.val:
                tmpNode = newHead.next.next
                while tmpNode and tmpNode.val == newHead.next.next.val:
                    tmpNode = tmpNode.next
								# newHead下一个指向了新数值
                newHead.next = tmpNode
            else:
                newHead = newHead.next
        return pHead.next
# 递归
class Solution:
    def deleteDuplication(self, pHead):
        if pHead is None or pHead.next is None:
            return pHead
        head1 = pHead.next
        if head1.val != pHead.val:
            pHead.next = self.deleteDuplication(pHead.next)
        else:
            while pHead.val == head1.val and head1.next is not None:
                head1 = head1.next
            if head1.val != pHead.val:
                pHead = self.deleteDuplication(head1)
            else:
                return None
        return pHead</code></pre><h3 id="a67b67bc-1592-4a63-a28d-2c8da10375b4" class="">57. 二叉树的下一个结点</h3><p id="e4452dc6-966e-40e8-83ef-acae1c83fc37" class="">给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><p id="c5ea4abb-84c3-4a89-a197-ac295bb22ce9" class=""><strong>题解</strong></p><figure id="6ecb9451-4fe6-4408-bce5-5427e2e0d71b" class="image"><a href="Offer/Untitled%2019.png"><img style="width:161px" src="Offer/Untitled%2019.png"/></a></figure><ol id="38e76022-64a4-4b07-99bc-551717cc2a67" class="numbered-list" start="1"><li>若该节点存在右子树：则下一个节点为右子树最左子节点（如图节点 B ）</li></ol><ol id="9aaf0a78-e6b1-4877-aa99-b292732dd061" class="numbered-list" start="2"><li>若该节点不存在右子树：这时分两种情况：<p id="bd04a80a-95b4-4292-9454-67f8c2c90e72" class="">2.1 该节点为父节点的左子节点，则下一个节点为其父节点（如图节点 D ）</p><p id="f22a3018-f817-42af-8436-e452d8e9b734" class="">2.2 该节点为父节点的右子节点，则沿着父节点向上遍历，知道找到一个节点的父节点的左子</p><p id="32a2da89-0d8d-4c1c-9533-5b7372683e7d" class="">节点为该节点，则该节点的父节点下一个节点（如图节点 I ，沿着父节点一直向上查找找到 B （ B 为其父节点的左子节点），则 B 的父节点 A 为下一个节点）。</p></li></ol><pre id="4f8c2858-5005-4930-8ba2-3fbfd25f9945" class="code"><code># class TreeLinkNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#         self.next = None
# 可将tmp全部替换为pNode，空间复杂度更低
class Solution:
    def GetNext(self, pNode):
        if pNode == None:
            return None
        if pNode.right != None:
            tmp = pNode.right
            while tmp.left != None:
                tmp = tmp.left
            return tmp
        else:
            if pNode.next != None and pNode == pNode.next.left:
                return pNode.next
            elif pNode.next != None and pNode == pNode.next.right:
                tmp = pNode.next
                while tmp.next != None and tmp == tmp.next.right:
                    tmp = tmp.next
                return tmp.next
            else:
                return pNode.next</code></pre><h3 id="782384fe-fb41-4b28-8765-43064fbe5bcd" class="">58. 对称的二叉树</h3><p id="ca7806c3-2a9a-4e5f-b219-56edd4fbd04b" class="">请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><p id="331b8ad8-dcec-4660-afea-13af841f6b5b" class=""><strong>题解</strong></p><ul id="94f601b2-3c6d-43de-8640-d25cc97bcb99" class="bulleted-list"><li>递归比较</li></ul><pre id="753567ce-3ebf-4d96-a650-6d710f636eac" class="code"><code>class Solution:
    def isSymmetrical(self, pRoot):
        if not pRoot:
            return True
        return self.compare(pRoot.left, pRoot.right)
    def compare(self, pRoot1, pRoot2):
        if not pRoot1 and not pRoot2:
            return True
        if not pRoot1 or not pRoot2:
            return False
        if pRoot1.val == pRoot2.val:
            if self.compare(pRoot1.left, pRoot2.right) and self.compare(pRoot1.right, pRoot2.left):
                return True
        return False</code></pre><h3 id="8bc82c66-35ff-4d5f-a4e7-60453132a1eb" class="">59. 按之字形顺序打印二叉树</h3><p id="85c43bed-b2e7-4a35-b897-87542fbb2371" class="">请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><p id="d2bc17d9-0fa5-49c1-9092-380ebe45349f" class=""><strong>题解</strong></p><ul id="04d6df95-71d6-4ee2-a1fa-8a70e55143af" class="bulleted-list"><li>从左到右存结点，偶数行reverse</li></ul><ul id="e46175ff-083d-49a7-b658-a8bdcd006a89" class="bulleted-list"><li>一个队列，一个栈</li></ul><pre id="c072de96-ab5f-4258-9911-eb79e62c204e" class="code"><code># 从左到右存结点
class Solution:
    def Print(self, pRoot):
        if not pRoot:
            return []
        nodeStack = [pRoot]
        res = []
				# 存结点，统一从左向右存
        while nodeStack:
            tmp = []
            nextStack = []
            for i in nodeStack:
                tmp.append(i.val)
                if i.left:
                    nextStack.append(i.left)
                if i.right:
                    nextStack.append(i.right)
            nodeStack = nextStack
            res.append(tmp)
				# 遍历res，每一个元素为二叉树一层的结点值（从左到右）
        result = []
        for i,v in enumerate(res):
            if i%2 == 0:
                result.append(v)
            else:
                result.append(v[::-1])
        return result</code></pre><h3 id="e4012643-a452-413c-8f8c-3051cc8ee2a5" class="">60. 把二叉树打印成多行</h3><p id="73605123-d55b-470e-8687-8d1ea9b57dd7" class="">从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><p id="2c3214a9-03ec-45cb-b75a-990c40e36efb" class=""><strong>题解</strong></p><ul id="1d3fc048-67f3-4c0b-99fb-385eded927bd" class="bulleted-list"><li>上题代码</li></ul><ul id="85e1fdd4-4389-4270-aba8-605837f0f4d8" class="bulleted-list"><li>递归</li></ul><pre id="39140919-1b6d-4853-9fcf-0613193841cf" class="code"><code># 数组存值
class Solution:
    # 返回二维列表[[1,2],[4,5]]
    def Print(self, pRoot):
        if not pRoot:
            return []
        nextNode = [pRoot]
        res = []
        while nextNode:
            tmp = []
            tValue = []
            for i in nextNode:
                tValue.append(i.val)
                if i.left:
                    tmp.append(i.left)
                if i.right:
                    tmp.append(i.right)
            nextNode = tmp
            res.append(tValue)
        return res
# 递归
class Solution:
    # 返回二维列表[[1,2],[4,5]]
    def Print(self, pRoot):
        if not pRoot:
            return []
        def depth(node, d):
            if node:
                if d &gt; len(res):
                    res.append([])
                res[d-1].append(node.val)
                depth(node.left, d+1)
                depth(node.right, d+1)
        res = []
        depth(pRoot, 1)
        return res</code></pre><h3 id="7c997f21-50a7-40eb-9e32-65ac8db4a087" class="">61. 序列化二叉树</h3><p id="7dee4610-a18e-4e18-bc72-6a9544590abe" class="">请实现两个函数，分别用来序列化和反序列化二叉树</p><p id="4d971713-81da-42a9-883b-3729cdee83a4" class="">二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p id="d1c02e23-b465-4b15-bd18-1439738c8344" class="">二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><p id="04793f55-1630-457c-8335-5bd191c77226" class=""><strong>题解</strong></p><pre id="387fdd24-653b-4db7-a33a-0075ecb0b0ac" class="code"><code>class Solution:
    def __init__(self):
        self.flag = -1
    def Serialize(self, root):
        if not root:
            return &#x27;#,&#x27;
        return str(root.val)+&#x27;,&#x27;+self.Serialize(root.left)+self.Serialize(root.right)
    def Deserialize(self, s):
        l = s.split(&#x27;,&#x27;)
        self.flag += 1
				# 判断字符串是否读完
        if self.flag &gt;= len(s):
            return None
        node = None
				# 构建结点
        if l[self.flag] != &#x27;#&#x27;:
            node = TreeNode(int(l[self.flag]))
            node.left = self.Deserialize(s)
            node.right = self.Deserialize(s)
        return node</code></pre><h3 id="9f3dc15b-dd7d-4bc5-bf3c-2ac51a52a44d" class="">62. 二叉搜索树的第k个结点</h3><p id="3c040c55-862c-47ad-9a17-4407248cfef9" class="">给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。</p><p id="6d2364d4-729a-4856-834b-8a53b1c1dc4a" class=""><strong>题解</strong></p><ul id="f8348020-2bba-4fa3-beb2-44aadd693fcc" class="bulleted-list"><li>中序遍历后找结点，空间复杂度高</li></ul><pre id="324d17ba-d2ff-4449-836d-1fa1656db444" class="code"><code>class Solution:
    # 返回对应节点TreeNode
    def KthNode(self, pRoot, k):
        if not pRoot:
            return None
        if k &lt;= 0:
            return None
        def recurTree(node):
            if node:
                recurTree(node.left)
                l.append(node)
                recurTree(node.right)
        l = []
        recurTree(pRoot)
        if k &gt; len(l):
            return None
        return l[k-1]</code></pre><h3 id="f251afeb-b028-4752-ae01-ed90a174f0b0" class="">63. 数据流中的中位数</h3><p id="e935e365-cd92-4df7-8e52-7f53a1e382b3" class="">如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><p id="5c79a2b6-eb35-484a-8b81-15a2dc99ff60" class=""><strong>题解</strong></p><p id="5c143bb5-fda2-4448-81ab-e9bde0dadd05" class="">一个小顶堆和大顶堆</p><p id="f498b07e-4a51-481b-95fd-02c903c1ab7e" class="">大顶堆用来存较小的数，从大到小排列；小顶堆存较大的数，从小到大的顺序排序<div class="indented"><ul id="b284d7fa-2fd1-4c0c-8e2a-247eba29bf2c" class="bulleted-list"><li>保证：小顶堆中的元素都大于等于大顶堆中的元素，所以每次塞值，并不是直接塞进去，而是从另一个堆中poll出一个最大（最小）的塞值</li></ul><ul id="f0ff796f-1e17-497f-90c3-9b409041985f" class="bulleted-list"><li>当数目为偶数的时候，将这个值插入大顶堆中，再将大顶堆中根节点（即最大值）插入到小顶堆中；</li></ul><ul id="cc7c9c9e-a384-4cad-bd84-191a35eb6d93" class="bulleted-list"><li>当数目为奇数的时候，将这个值插入小顶堆中，再讲小顶堆中根节点（即最小值）插入到大顶堆中；</li></ul><ul id="8ba35712-2813-4263-8a14-292627eaddb1" class="bulleted-list"><li>取中位数的时候，如果当前个数为偶数，显然是取小顶堆和大顶堆根结点的平均值；如果当前个数为奇数，显然是取小顶堆的根节点</li></ul></div></p><p id="1d826e76-ff9f-4b66-b842-c3da9307563d" class="">例如，传入的数据为：[5,2,3,4,1,6,7,0,8]，输出是&quot;5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 &quot;</p><p id="ff090990-c145-405b-a852-c19aaefe9669" class="">那么整个程序的执行流程应该是（用min表示小顶堆，max表示大顶堆）：</p><ul id="d96b9e5b-8332-4d44-9076-b4c42e356e09" class="bulleted-list"><li>5先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，min=[5], max=[None], med=5.00</li></ul><ul id="bddff9f2-a038-4c0b-92e3-dd10fac88326" class="bulleted-list"><li>2先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，min=[5], max=[2], med=(5+2)/2=3.50</li></ul><ul id="09e305d9-e1fe-4c47-bdea-4c7545e19de4" class="bulleted-list"><li>3先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，min=[3,5], max=[2], med=3.00</li></ul><ul id="64a7015c-2f22-4171-9a7a-b187c33b90ff" class="bulleted-list"><li>4先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，min=[4,5], max=[3,2], med=(4+3)/2=3.50</li></ul><ul id="62926267-05c2-4ca8-bb93-e3a083023f52" class="bulleted-list"><li>1先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，min=[3,4,5], max=[2,1], med=3.00</li></ul><ul id="d2f542e8-f5b6-4256-8d9d-1b6251dd8767" class="bulleted-list"><li>6先进入小顶堆，然后将小顶堆中最小值放入大顶堆中，min=[4,5,6], max=[3,2,1], med=(4+3)/2=3.50</li></ul><ul id="10576161-73ff-4f9c-a2be-b01f5f79bcca" class="bulleted-list"><li>7先进入大顶堆，然后将大顶堆中最大值放入小顶堆中，min=[4,5,6,7], max=[3,2,1], med=4.00</li></ul><ul id="6244713b-1228-4846-8f93-23b75ec77c6f" class="bulleted-list"><li>0先进入小顶堆，然后将小顶堆中最大值放入小顶堆中，min=[4,5,6,7], max=[3,2,1,0], med=(4+3)/2=3.50</li></ul><ul id="a4ceeaec-d0e4-4488-adf2-8350d3589681" class="bulleted-list"><li>8先进入大顶堆，然后将大顶堆中最小值放入大顶堆中，min=[4,5,6,7,8], max=[3,2,1,0], med=4.00</li></ul><pre id="9b1b2d23-122d-4d82-a418-9ebaf72b6506" class="code"><code>class Solution:
    def __init__(self):
        self.minNums=[]
        self.maxNums=[]
 
    def maxHeapInsert(self,num):
        self.maxNums.append(num)
        lens = len(self.maxNums)
        i = lens - 1
        while i &gt; 0:
            if self.maxNums[i] &gt; self.maxNums[(i - 1) / 2]:
                t = self.maxNums[(i - 1) / 2]
                self.maxNums[(i - 1) / 2] = self.maxNums[i]
                self.maxNums[i] = t
                i = (i - 1) / 2
            else:
                break
 
    def maxHeapPop(self):
        t = self.maxNums[0]
        self.maxNums[0] = self.maxNums[-1]
        self.maxNums.pop()
        lens = len(self.maxNums)
        i = 0
        while 2 * i + 1 &lt; lens:
            nexti = 2 * i + 1
            if (nexti + 1 &lt; lens) and self.maxNums[nexti + 1] &gt; self.maxNums[nexti]:
                nexti += 1
            if self.maxNums[nexti] &gt; self.maxNums[i]:
                tmp = self.maxNums[i]
                self.maxNums[i] = self.maxNums[nexti]
                self.maxNums[nexti] = tmp
                i = nexti
            else:
                break
        return  t
 
    def minHeapInsert(self,num):
        self.minNums.append(num)
        lens = len(self.minNums)
        i = lens - 1
        while i &gt; 0:
            if self.minNums[i] &lt; self.minNums[(i - 1) / 2]:
                t = self.minNums[(i - 1) / 2]
                self.minNums[(i - 1) / 2] = self.minNums[i]
                self.minNums[i] = t
                i = (i - 1) / 2
            else:
                break
 
    def minHeapPop(self):
        t = self.minNums[0]
        self.minNums[0] = self.minNums[-1]
        self.minNums.pop()
        lens = len(self.minNums)
        i = 0
        while 2 * i + 1 &lt; lens:
            nexti = 2 * i + 1
            if (nexti + 1 &lt; lens) and self.minNums[nexti + 1] &lt; self.minNums[nexti]:
                nexti += 1
            if self.minNums[nexti] &lt; self.minNums[i]:
                tmp = self.minNums[i]
                self.minNums[i] = self.minNums[nexti]
                self.minNums[nexti] = tmp
                i = nexti
            else:
                break
        return t
 
    def Insert(self, num):
        if (len(self.minNums)+len(self.maxNums))&amp;1 == 0:
            if len(self.maxNums)&gt;0 and num &lt; self.maxNums[0]:
                self.maxHeapInsert(num)
                num = self.maxHeapPop()
            self.minHeapInsert(num)
        else:
            if len(self.minNums)&gt;0 and num &gt; self.minNums[0]:
                self.minHeapInsert(num)
                num = self.minHeapPop()
            self.maxHeapInsert(num)
 
    def GetMedian(self):
        allLen = len(self.minNums) + len(self.maxNums)
        if allLen == 0:
            return -1
        if allLen&amp;1 == 1:
            return self.minNums[0]
        else:
            return (self.maxNums[0] + self.minNums[0])/2.0</code></pre><h3 id="df640cd1-1411-4ea1-993d-7387240cd4d6" class="">64. 滑动窗口的最大值</h3><p id="1acd5550-f7e3-4c01-84fe-566ac8744f82" class="">给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p id="4b9394a5-658f-4443-b103-6a64e904c81b" class=""><strong>题解</strong></p><ul id="f903a1d3-15a2-4b7b-8b5a-2823f8ca0b71" class="bulleted-list"><li>max, 时间复杂度O(n*size)</li></ul><ul id="787b0281-a0dd-4e09-9ac8-6630a1006e33" class="bulleted-list"><li>双向队列，queue存入num的位置，时间复杂度O(n)<p id="92f82829-49a0-4e03-be74-9a9187a0aae5" class="">用一个双端队列，队列第一个位置保存当前窗口的最大值，当窗口滑动一次
1.判断当前最大值是否过期
2.新增加的值从队尾开始比较，把所有比他小的值丢掉</p></li></ul><pre id="ad74fb2e-0c8e-41fc-b181-c532b0c5acce" class="code"><code># max
class Solution:
    def maxInWindows(self, num, size):
        if not num or size &lt;= 0:
            return []
        n = len(num)
        if size &gt; n:
            return []
        res = []
        for i in range(n-size+1):
            tmp = num[i:i+size]
            res.append(max(tmp))
        return res
# 双向队列
class Solution:
    def maxInWindows(self, num, size):
				queue,res,i = [],[],0
				while size&gt;0 and i&lt;len(num):
						#若最大值queue[0]位置过期，则弹出
				    if len(queue)&gt;0 and i-size+1 &gt; queue[0]:
				        queue.pop(0)
						#每次弹出所有比num[i]小的数字
				    while len(queue)&gt;0 and num[queue[-1]]&lt;num[i]: 
				        queue.pop()
				    queue.append(i)
				    if i&gt;=size-1:
				        res.append(num[queue[0]])
				    i += 1
				return res</code></pre><h3 id="16456b90-0a98-439e-a5ef-30794f89447f" class="">65. 矩阵中的路径</h3><p id="2df1dcc6-d0c7-4406-a6e4-82e116f395b0" class="">请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如</p><figure id="3d1f8146-880d-41a3-b6b8-f40d7ba78c95" class="equation"><style>@import url('https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css')</style><div class="equation-container"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo fence="true">[</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>b</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>e</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>s</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>f</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>c</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>s</mi></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>a</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>d</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>e</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>e</mi></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix} a&amp;b&amp;c&amp;e\\ s&amp;f&amp;c&amp;s \\ a&amp;d&amp;e&amp;e \end{bmatrix}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">b</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">d</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">c</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">e</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">s</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">e</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span></span></div></figure><p id="c65efc20-c4c5-4035-8dba-10c783cce09e" class="">矩阵中包含一条字符串&quot;bcced&quot;的路径，但是矩阵中不包含&quot;abcb&quot;路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><p id="3e432a85-a15d-472d-b869-d27c1cfcb154" class=""><strong>题解</strong></p><p id="6d76b75f-d095-49d2-aee0-9f4598ecf2c4" class="">回溯法</p><pre id="64013ef7-1fa6-4899-82e2-7ecdd4b9421e" class="code"><code>class Solution:
    def hasPath(self, matrix, rows, cols, path):
        # write code here
        if not matrix:
            return False
        if not path:
            return True
        x = [list(matrix[cols*i:cols*i+cols]) for i in range(rows)]
        for i in range(rows):
            for j in range(cols):
                if self.exist_helper(x, i, j, path):
                    return True
        return False
    def exist_helper(self, matrix, i, j, p):
        if matrix[i][j] == p[0]:
            if not p[1:]:
                return True
            matrix[i][j] = &#x27;&#x27;
            if i &gt; 0 and self.exist_helper(matrix, i-1, j, p[1:]):
                return True
            if i &lt; len(matrix)-1 and self.exist_helper(matrix, i+1, j ,p[1:]):
                return True
            if j &gt; 0 and self.exist_helper(matrix, i, j-1, p[1:]):
                return True
            if j &lt; len(matrix[0])-1 and self.exist_helper(matrix, i, j+1, p[1:]):
                return True
            matrix[i][j] = p[0]
            return False
        else:
            return False
# 不懂错在哪
class Solution():
    def hasPath(self, matrix, rows, cols, path):
        x = [list(matrix[cols*row:cols*row+cols]) for row in range(rows)]
        matrix = x
        position = []
        for i in path:
            tmp = []
            for row in range(rows):
                for col in range(cols):
                    if matrix[row][col] == i:
                        tmp.append([row,col])
            if len(tmp) == 0:
                return False
            position.append(tmp)
        print(position)
        flag = False
        if self.back(position, [], 0, flag):
            return True
        return False
    def back(self, position, tmp, step, flag):
        if step == len(position):
            trueCount = 0
            for j in range(len(tmp)-1):
                if tmp[j]==tmp[j+1] or abs(tmp[j][0]-tmp[j+1][0])&gt;1 or abs(tmp[j][1]-tmp[j+1][1])&gt;1:
                    break
                else:
                    trueCount += 1
            if trueCount == len(tmp)-1:
                return True
        if step &lt; len(position):
            for i in position[step]:
                tmp.append(i)
                self.back(position, tmp, step+1, flag)
                tmp.pop()</code></pre><h3 id="61856d84-06de-4ced-bf09-58a52f84cfdb" class="">66. 机器人的运动范围</h3><p id="2240aaed-b7e8-48c6-a2e4-a5d925250658" class="">地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><p id="d0766a52-9c62-410e-a43d-db50511a683d" class=""><strong>题解</strong></p><pre id="048a076b-f9b0-4605-a299-73c9645a01fd" class="code"><code># 递归
class Solution:
    def movingCount(self, threshold, rows, cols):
        if threshold &lt; 0:
            return 0
        record = []
        def move(row, col):
            record.append([row, col])
            def sumNumber(n):
                return sum(map(int,[i for i in str(n)]))
            # left
            if col&gt;0 and sumNumber(row)+sumNumber(col-1)&lt;=threshold:
                if [row, col-1] not in record:
                    move(row, col-1)
            # right
            if col&lt;cols-1 and sumNumber(row)+sumNumber(col+1)&lt;=threshold:
                if [row, col+1] not in record:
                    move(row, col+1)
            # up
            if row&gt;0 and sumNumber(row-1)+sumNumber(col)&lt;=threshold:
                if [row-1, col] not in record:
                    move(row-1, col)
            # down
            if row&lt;rows-1 and sumNumber(row+1)+sumNumber(col)&lt;=threshold:
                if [row+1, col] not in record:
                    move(row+1, col)
        move(0, 0)
        return len(record)
# 递归精简版
class Solution:
    def __init__(self):
        self.count = 0
 
    def movingCount(self, threshold, rows, cols):
        # write code here
        arr = [[1 for i in range(cols)] for j in range(rows)]
        self.findway(arr, 0, 0, threshold)
        return self.count
 
    def findway(self, arr, i, j, k):
        if i &lt; 0 or j &lt; 0 or i &gt;= len(arr) or j &gt;= len(arr[0]):
            return
        tmpi = list(map(int, list(str(i))))
        tmpj = list(map(int, list(str(j))))
        if sum(tmpi) + sum(tmpj) &gt; k or arr[i][j] != 1:
            return
        arr[i][j] = 0
        self.count += 1
        self.findway(arr, i + 1, j, k)
        self.findway(arr, i - 1, j, k)
        self.findway(arr, i, j + 1, k)
        self.findway(arr, i, j - 1, k)</code></pre><h3 id="7ccf7627-1b44-427b-a81f-dc58e3bbc1a4" class="">67. 剪绳子</h3><p id="b436f2ef-c745-4680-9141-1dcdd5a94dfa" class="">给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],...,k[m]。请问k[0]xk[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p id="981fde81-fe8a-4804-8403-2bbbc74808fa" class="">输入描述:</p><p id="2883ed24-b16b-4db4-850c-0b3cf58349aa" class="">输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）</p><p id="885f99e4-62fb-45f3-9ef1-e2edf0352acd" class=""><strong>示例</strong></p><p id="48384074-256f-46e9-b5a4-1923f347555f" class="">输入：8</p><p id="8f07f99a-c518-4a5e-a17c-29a119f8866c" class="">输出：18</p><p id="1689bec4-e0cd-449b-a6d0-12b825395309" class=""><strong>题解</strong></p><ul id="9964f828-a9e1-4812-8638-7dc3065844bd" class="bulleted-list"><li>动态规划<p id="ad46c627-f620-457c-97e9-fcf6197e5274" class="">问题的最优解一定是由子问题的最优解构成：<div class="indented"><p id="174a5cbf-df63-436c-9a05-c11abe3b5423" class="">如果一个长度为n的绳子可以分为 n = s[1] + s[2] + s[3] + s[4] 这么几个段， 那么一定有 max = s[1]*s[2]*s[3]*s[4], 且 s[1] * s[2] 为长度是 s[1]+[s2]的子问题的最优解,同理s[3]*s[4]一定是s[3]+s[4]的最优解,所以我们知道 n 其实可以表示为上述两段的最优解.</p></div></p><p id="8e0445aa-a6e8-494b-a9b9-63b5cf59b381" class="">当绳子长度大于等于4的时候，不管对绳子割几刀，总可以把问题看成，先割一刀（长度在1-n）之间，考虑对称性第一刀范围在1-n/2之间</p></li></ul><ul id="557b57b9-e812-44f5-b11d-3c7051cbbcf4" class="bulleted-list"><li>贪婪算法、乘方运算<p id="36416149-c868-4f3d-9df6-59360b9e4770" class="">先举几个例子，可以看出规律来。
4 ： 2*2
5 ： 2*3
6 ： 3*3
7 ： 2*2*3 或者4*3
8 ： 2*3*3
9 ： 3*3*3
10：2*2*3*3 或者4*3*3
11：2*3*3*3
12：3*3*3*3
13：2*2*3*3*3 或者4*3*3*3

下面是分析：
首先判断k[0]到k[m]可能有哪些数字，实际上只可能是2或者3。
当然也可能有4，但是4=2*2，我们就简单些不考虑了。
5&lt;2*3,6&lt;3*3,比6更大的数字我们就更不用考虑了，肯定要继续分。
其次看2和3的数量，2的数量肯定小于3个，为什么呢？因为2*2*2&lt;3*3，那么题目就简单了。
直接用n除以3，根据得到的余数判断是一个2还是两个2还是没有2就行了。
由于题目规定m&gt;1，所以2只能是1*1，3只能是2*1，这两个特殊情况直接返回就行了。

乘方运算的复杂度为：O(log n)，用动态规划来做会耗时比较多。</p><p id="49afeda7-23f6-4182-a128-db82d21bf76b" class="">
</p><p id="2974d77f-00a8-42bd-a6cf-2664d470948a" class="">f(x)=(x)^(n/x)，最大时x为e也即2.718。取整的话f(3) &gt; f(2)</p><figure id="93000d1e-5fc3-450e-940f-5158e2e0cd64" class="image"><a href="Offer/Untitled%2020.png"><img style="width:432px" src="Offer/Untitled%2020.png"/></a></figure></li></ul><pre id="9499456e-f791-4671-9917-11f88f706662" class="code"><code># 动态规划
class Solution:
    def cutRope(self, number):
				# 给定初始值
        if number&lt;=1:
            return 0
        elif number&lt;=2:
            return 1
        elif number&lt;=3:
            return 2
				# 定义最大值数组
        prod=[0,1,2,3]
        for i in range(4,number+1):
						# max 初始化为 一分的结果(本身)
            max=0
						# 对于最少二分做解
            for j in range(1,i//2+1):
                pro=prod[j]*prod[i-j]
                if pro&gt;max:
                    max=pro
            prod.append(max)
        return prod[number]
# 贪婪算法
class Solution:
    def cutRope(self, number):
        res=1
        if number&lt;=1:
            return 0
        elif number&lt;=2:
            return 1
        elif number&lt;=3:
            return 2
        elif number&gt;3:
            if number%3==0:
                res=3**(number//3)
            elif number%3==1:
                res=3**(number//3-1)*4
            else:
                res=3**(number//3)*(number%3)
        return res</code></pre></div></article></body></html>